import _extends from '@babel/runtime/helpers/esm/extends';
import React, { forwardRef, useMemo } from 'react';
import * as FIBER from '@react-three/fiber';
import { Material, MathUtils } from 'three';
import hash from 'object-hash';
import tokenize from 'glsl-tokenizer';
import stringify from 'glsl-token-string';
import tokenFunctions from 'glsl-token-functions';

var keywords = {
  position: 'csm_Position',
  positionRaw: 'csm_PositionRaw',
  pointSize: 'csm_PointSize',
  fragColor: 'csm_FragColor',
  // PBR
  diffuseColor: 'csm_DiffuseColor',
  normal: 'csm_Normal',
  roughness: 'csm_Roughness',
  metalness: 'csm_Metalness',
  emissive: 'csm_Emissive'
};

const defaultPatchMap = {
  // VERT
  [`${keywords.normal}`]: {
    '#include <beginnormal_vertex>': `
    vec3 objectNormal = ${keywords.normal};
    #ifdef USE_TANGENT
	    vec3 objectTangent = vec3( tangent.xyz );
    #endif
    `
  },
  [`${keywords.position}`]: {
    '#include <begin_vertex>': `
    vec3 transformed = ${keywords.position};
  `
  },
  [`${keywords.positionRaw}`]: {
    '#include <begin_vertex>': `
    vec4 csm_positionUnprojected = ${keywords.positionRaw};
    mat4x4 csm_unprojectMatrix = projectionMatrix * modelViewMatrix;
    #ifdef USE_INSTANCING
      csm_unprojectMatrix = csm_unprojectMatrix * instanceMatrix;
    #endif
    csm_positionUnprojected = inverse(csm_unprojectMatrix) * csm_positionUnprojected;
    vec3 transformed = csm_positionUnprojected.xyz;
  `
  },
  [`${keywords.pointSize}`]: {
    'gl_PointSize = size;': `
    gl_PointSize = ${keywords.pointSize};
    `
  },
  // FRAG
  [`${keywords.diffuseColor}`]: {
    '#include <color_fragment>': `
    #include <color_fragment>
    diffuseColor = ${keywords.diffuseColor};
  `
  },
  [`${keywords.fragColor}`]: {
    '#include <dithering_fragment>': `
    #include <dithering_fragment>
    gl_FragColor  = ${keywords.fragColor};
  `
  },
  [`${keywords.emissive}`]: {
    'vec3 totalEmissiveRadiance = emissive;': `
    vec3 totalEmissiveRadiance = ${keywords.emissive};
    `
  },
  [`${keywords.roughness}`]: {
    '#include <roughnessmap_fragment>': `
    #include <roughnessmap_fragment>
    roughnessFactor = ${keywords.roughness};
    `
  },
  [`${keywords.metalness}`]: {
    '#include <metalnessmap_fragment>': `
    #include <metalnessmap_fragment>
    metalnessFactor = ${keywords.metalness};
    `
  }
};
const shaderMaterial_PatchMap = {
  // VERT
  [`${keywords.position}`]: {
    'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );': `
    gl_Position = projectionMatrix * modelViewMatrix * vec4( ${keywords.position}, 1.0 );
  `
  },
  [`${keywords.positionRaw}`]: {
    'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );': `
    gl_Position = ${keywords.position};
  `
  },
  // FRAG
  [`${keywords.diffuseColor}`]: {
    'gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );': `
    gl_FragColor = ${keywords.diffuseColor};
  `
  },
  [`${keywords.fragColor}`]: {
    'gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );': `
    gl_FragColor = ${keywords.fragColor};
  `
  }
};

const defaultDefinitions =
/* glsl */
`

#ifdef IS_VERTEX
    vec3 csm_Position = position;
    vec4 csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);
    vec3 csm_Normal = normal;
#else
    #if defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHNORMALMATERIAL
        vec4 csm_DiffuseColor = vec4(1., 0., 1., 1.);
        vec4 csm_FragColor = vec4(1., 0., 1., 1.);
    #else
        #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
            vec3 csm_Emissive = emissive;
            float csm_Roughness = roughness;
            float csm_Metalness = metalness;
        #endif
        
        #ifdef USE_MAP
            vec4 _csm_sampledDiffuseColor = texture2D(map, vUv);

            #ifdef DECODE_VIDEO_TEXTURE
            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);
            #endif

            vec4 csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
            vec4 csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
        #else
            vec4 csm_DiffuseColor = vec4(diffuse, opacity);
            vec4 csm_FragColor = vec4(diffuse, opacity);
        #endif
    #endif
#endif
`;

const replaceAll = (str, find, rep) => str.split(find).join(rep);

const escapeRegExpMatch = function (s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};

const isExactMatch = (str, match) => {
  return new RegExp(`\\b${escapeRegExpMatch(match)}\\b`).test(str);
};

function isConstructor(f) {
  try {
    // @ts-ignore
    new f();
  } catch (err) {
    if (err.message.indexOf('is not a constructor') >= 0) {
      return false;
    }
  }

  return true;
}
class CustomShaderMaterial extends Material {
  constructor({
    baseMaterial,
    fragmentShader,
    vertexShader,
    uniforms,
    patchMap,
    cacheKey,
    ...opts
  }) {
    let base;

    if (isConstructor(baseMaterial)) {
      base = new baseMaterial(opts);
    } else {
      base = baseMaterial;
      Object.assign(base, opts);
    }

    if (base.type === 'RawShaderMaterial') {
      throw new Error('CustomShaderMaterial does not support RawShaderMaterial');
    }

    super();
    this.uniforms = uniforms || {};
    this._customPatchMap = patchMap || {};
    this._fs = fragmentShader || '';
    this._vs = vertexShader || '';
    this._cacheKey = cacheKey;
    this._base = baseMaterial;
    this._type = base.type;
    this._instanceID = MathUtils.generateUUID();

    for (const key in base) {
      let k = key;

      if (key.startsWith('_')) {
        k = key.split('_')[1];
      } // @ts-ignore


      if (this[k] === undefined) this[k] = 0; // @ts-ignore

      this[k] = base[k];
    }

    this.update({
      fragmentShader,
      vertexShader,
      uniforms,
      cacheKey
    });
  }

  update(opts) {
    const uniforms = (opts == null ? void 0 : opts.uniforms) || {};
    const fragmentShader = (opts == null ? void 0 : opts.fragmentShader) || this._fs;
    const vertexShader = (opts == null ? void 0 : opts.vertexShader) || this._vs;
    const serializedUniforms = Object.values(uniforms).reduce((prev, {
      value
    }) => {
      return prev + JSON.stringify(value);
    }, '');
    this.uuid = (opts == null ? void 0 : opts.cacheKey == null ? void 0 : opts.cacheKey()) || hash([fragmentShader, vertexShader, serializedUniforms, this._instanceID]);
    this.generateMaterial({
      fragmentShader,
      vertexShader,
      uniforms
    });
  }

  clone() {
    // @ts-ignore
    const c = new this.constructor({
      baseMaterial: this._base,
      fragmentShader: this._fs,
      vertexShader: this._vs,
      patchMap: this._customPatchMap,
      uniforms: this.uniforms,
      cacheKey: this._cacheKey
    });

    for (const key in this) {
      if (key === 'uuid') continue; // @ts-ignore

      c[key] = this[key];
    }

    return c;
  }

  generateMaterial({
    fragmentShader,
    vertexShader,
    uniforms
  }) {
    const parsedFragmentShader = this.parseShader(fragmentShader);
    const parsedVertexShader = this.parseShader(vertexShader);
    this.uniforms = uniforms || {};

    this.customProgramCacheKey = () => {
      return this.uuid;
    };

    this.onBeforeCompile = shader => {
      if (parsedFragmentShader) {
        const patchedFragmentShader = this.patchShader(parsedFragmentShader, shader.fragmentShader);
        shader.fragmentShader = this.getMaterialDefine() + patchedFragmentShader;
      }

      if (parsedVertexShader) {
        const patchedVertexShader = this.patchShader(parsedVertexShader, shader.vertexShader);
        shader.vertexShader = '#define IS_VERTEX;\n' + patchedVertexShader;
        shader.vertexShader = this.getMaterialDefine() + shader.vertexShader;
      }

      shader.uniforms = { ...shader.uniforms,
        ...this.uniforms
      };
      this.uniforms = shader.uniforms;
    };

    this.needsUpdate = true;
  }

  getMaterialDefine() {
    return `#define IS_${this._type.toUpperCase()};\n`;
  }

  getPatchMapForMaterial() {
    switch (this._type) {
      case 'ShaderMaterial':
        return shaderMaterial_PatchMap;

      default:
        return defaultPatchMap;
    }
  }

  patchShader(customShader, shader) {
    let patchedShader = shader;
    const patchMap = { ...this.getPatchMapForMaterial(),
      ...this._customPatchMap
    };
    Object.keys(patchMap).forEach(name => {
      Object.keys(patchMap[name]).forEach(key => {
        if (isExactMatch(customShader.main, name)) {
          patchedShader = replaceAll(patchedShader, key, patchMap[name][key]);
        }
      });
    });
    patchedShader = patchedShader.replace('void main() {', `
          ${customShader.header}
          void main() {
            ${defaultDefinitions}
            ${customShader.main}
          `);
    patchedShader = customShader.defines + patchedShader;
    return patchedShader;
  }

  parseShader(shader) {
    if (!shader) return; // Strip comments

    const s = shader.replace(/\/\*\*(.*?)\*\/|\/\/(.*?)\n/gm, '');
    const tokens = tokenize(s);
    const funcs = tokenFunctions(tokens);
    const mainIndex = funcs.map(e => {
      return e.name;
    }).indexOf('main');
    const variables = stringify(tokens.slice(0, mainIndex >= 0 ? funcs[mainIndex].outer[0] : undefined));
    const mainBody = mainIndex >= 0 ? this.getShaderFromIndex(tokens, funcs[mainIndex].body) : '';
    return {
      defines: '',
      header: variables,
      main: mainBody
    };
  }

  getShaderFromIndex(tokens, index) {
    return stringify(tokens.slice(index[0], index[1]));
  }

}

FIBER.extend({
  CustomShaderMaterial_: CustomShaderMaterial
});
var index = /*#__PURE__*/forwardRef(({
  baseMaterial,
  fragmentShader,
  vertexShader,
  uniforms,
  patchMap,
  cacheKey,
  ...rest
}, ref) => {
  const args = useMemo(() => [{
    baseMaterial,
    fragmentShader,
    vertexShader,
    patchMap,
    uniforms,
    cacheKey
  }], [baseMaterial, fragmentShader, vertexShader, uniforms, cacheKey]); // @ts-ignore

  return /*#__PURE__*/React.createElement("customShaderMaterial_", _extends({
    args: args,
    attach: "material"
  }, rest, {
    ref: ref
  }));
});

export { index as default };
