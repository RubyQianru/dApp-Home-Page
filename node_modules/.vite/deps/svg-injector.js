import {
  __commonJS
} from "./chunk-AUZ3RYOM.js";

// node_modules/svg-injector/svg-injector.js
var require_svg_injector = __commonJS({
  "node_modules/svg-injector/svg-injector.js"(exports, module) {
    (function(window2, document2) {
      "use strict";
      var isLocal = window2.location.protocol === "file:";
      var hasSvgSupport = document2.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
      function uniqueClasses(list) {
        list = list.split(" ");
        var hash = {};
        var i = list.length;
        var out = [];
        while (i--) {
          if (!hash.hasOwnProperty(list[i])) {
            hash[list[i]] = 1;
            out.unshift(list[i]);
          }
        }
        return out.join(" ");
      }
      var forEach = Array.prototype.forEach || function(fn, scope) {
        if (this === void 0 || this === null || typeof fn !== "function") {
          throw new TypeError();
        }
        var i, len = this.length >>> 0;
        for (i = 0; i < len; ++i) {
          if (i in this) {
            fn.call(scope, this[i], i, this);
          }
        }
      };
      var svgCache = {};
      var injectCount = 0;
      var injectedElements = [];
      var requestQueue = [];
      var ranScripts = {};
      var cloneSvg = function(sourceSvg) {
        return sourceSvg.cloneNode(true);
      };
      var queueRequest = function(url, callback) {
        requestQueue[url] = requestQueue[url] || [];
        requestQueue[url].push(callback);
      };
      var processRequestQueue = function(url) {
        for (var i = 0, len = requestQueue[url].length; i < len; i++) {
          (function(index) {
            setTimeout(function() {
              requestQueue[url][index](cloneSvg(svgCache[url]));
            }, 0);
          })(i);
        }
      };
      var loadSvg = function(url, callback) {
        if (svgCache[url] !== void 0) {
          if (svgCache[url] instanceof SVGSVGElement) {
            callback(cloneSvg(svgCache[url]));
          } else {
            queueRequest(url, callback);
          }
        } else {
          if (!window2.XMLHttpRequest) {
            callback("Browser does not support XMLHttpRequest");
            return false;
          }
          svgCache[url] = {};
          queueRequest(url, callback);
          var httpRequest = new XMLHttpRequest();
          httpRequest.onreadystatechange = function() {
            if (httpRequest.readyState === 4) {
              if (httpRequest.status === 404 || httpRequest.responseXML === null) {
                callback("Unable to load SVG file: " + url);
                if (isLocal)
                  callback("Note: SVG injection ajax calls do not work locally without adjusting security setting in your browser. Or consider using a local webserver.");
                callback();
                return false;
              }
              if (httpRequest.status === 200 || isLocal && httpRequest.status === 0) {
                if (httpRequest.responseXML instanceof Document) {
                  svgCache[url] = httpRequest.responseXML.documentElement;
                } else if (DOMParser && DOMParser instanceof Function) {
                  var xmlDoc;
                  try {
                    var parser = new DOMParser();
                    xmlDoc = parser.parseFromString(httpRequest.responseText, "text/xml");
                  } catch (e) {
                    xmlDoc = void 0;
                  }
                  if (!xmlDoc || xmlDoc.getElementsByTagName("parsererror").length) {
                    callback("Unable to parse SVG file: " + url);
                    return false;
                  } else {
                    svgCache[url] = xmlDoc.documentElement;
                  }
                }
                processRequestQueue(url);
              } else {
                callback("There was a problem injecting the SVG: " + httpRequest.status + " " + httpRequest.statusText);
                return false;
              }
            }
          };
          httpRequest.open("GET", url);
          if (httpRequest.overrideMimeType)
            httpRequest.overrideMimeType("text/xml");
          httpRequest.send();
        }
      };
      var injectElement = function(el, evalScripts, pngFallback, callback) {
        var imgUrl = el.getAttribute("data-src") || el.getAttribute("src");
        if (!/\.svg/i.test(imgUrl)) {
          callback("Attempted to inject a file with a non-svg extension: " + imgUrl);
          return;
        }
        if (!hasSvgSupport) {
          var perElementFallback = el.getAttribute("data-fallback") || el.getAttribute("data-png");
          if (perElementFallback) {
            el.setAttribute("src", perElementFallback);
            callback(null);
          } else if (pngFallback) {
            el.setAttribute("src", pngFallback + "/" + imgUrl.split("/").pop().replace(".svg", ".png"));
            callback(null);
          } else {
            callback("This browser does not support SVG and no PNG fallback was defined.");
          }
          return;
        }
        if (injectedElements.indexOf(el) !== -1) {
          return;
        }
        injectedElements.push(el);
        el.setAttribute("src", "");
        loadSvg(imgUrl, function(svg) {
          if (typeof svg === "undefined" || typeof svg === "string") {
            callback(svg);
            return false;
          }
          var imgId = el.getAttribute("id");
          if (imgId) {
            svg.setAttribute("id", imgId);
          }
          var imgTitle = el.getAttribute("title");
          if (imgTitle) {
            svg.setAttribute("title", imgTitle);
          }
          var classMerge = [].concat(svg.getAttribute("class") || [], "injected-svg", el.getAttribute("class") || []).join(" ");
          svg.setAttribute("class", uniqueClasses(classMerge));
          var imgStyle = el.getAttribute("style");
          if (imgStyle) {
            svg.setAttribute("style", imgStyle);
          }
          var imgData = [].filter.call(el.attributes, function(at) {
            return /^data-\w[\w\-]*$/.test(at.name);
          });
          forEach.call(imgData, function(dataAttr) {
            if (dataAttr.name && dataAttr.value) {
              svg.setAttribute(dataAttr.name, dataAttr.value);
            }
          });
          var iriElementsAndProperties = {
            "clipPath": ["clip-path"],
            "color-profile": ["color-profile"],
            "cursor": ["cursor"],
            "filter": ["filter"],
            "linearGradient": ["fill", "stroke"],
            "marker": ["marker", "marker-start", "marker-mid", "marker-end"],
            "mask": ["mask"],
            "pattern": ["fill", "stroke"],
            "radialGradient": ["fill", "stroke"]
          };
          var element, elementDefs, properties, currentId, newId;
          Object.keys(iriElementsAndProperties).forEach(function(key) {
            element = key;
            properties = iriElementsAndProperties[key];
            elementDefs = svg.querySelectorAll("defs " + element + "[id]");
            for (var i = 0, elementsLen = elementDefs.length; i < elementsLen; i++) {
              currentId = elementDefs[i].id;
              newId = currentId + "-" + injectCount;
              var referencingElements;
              forEach.call(properties, function(property) {
                referencingElements = svg.querySelectorAll("[" + property + '*="' + currentId + '"]');
                for (var j = 0, referencingElementLen = referencingElements.length; j < referencingElementLen; j++) {
                  referencingElements[j].setAttribute(property, "url(#" + newId + ")");
                }
              });
              elementDefs[i].id = newId;
            }
          });
          svg.removeAttribute("xmlns:a");
          var scripts = svg.querySelectorAll("script");
          var scriptsToEval = [];
          var script, scriptType;
          for (var k = 0, scriptsLen = scripts.length; k < scriptsLen; k++) {
            scriptType = scripts[k].getAttribute("type");
            if (!scriptType || scriptType === "application/ecmascript" || scriptType === "application/javascript") {
              script = scripts[k].innerText || scripts[k].textContent;
              scriptsToEval.push(script);
              svg.removeChild(scripts[k]);
            }
          }
          if (scriptsToEval.length > 0 && (evalScripts === "always" || evalScripts === "once" && !ranScripts[imgUrl])) {
            for (var l = 0, scriptsToEvalLen = scriptsToEval.length; l < scriptsToEvalLen; l++) {
              new Function(scriptsToEval[l])(window2);
            }
            ranScripts[imgUrl] = true;
          }
          var styleTags = svg.querySelectorAll("style");
          forEach.call(styleTags, function(styleTag) {
            styleTag.textContent += "";
          });
          el.parentNode.replaceChild(svg, el);
          delete injectedElements[injectedElements.indexOf(el)];
          el = null;
          injectCount++;
          callback(svg);
        });
      };
      var SVGInjector = function(elements, options, done) {
        options = options || {};
        var evalScripts = options.evalScripts || "always";
        var pngFallback = options.pngFallback || false;
        var eachCallback = options.each;
        if (elements.length !== void 0) {
          var elementsLoaded = 0;
          forEach.call(elements, function(element) {
            injectElement(element, evalScripts, pngFallback, function(svg) {
              if (eachCallback && typeof eachCallback === "function")
                eachCallback(svg);
              if (done && elements.length === ++elementsLoaded)
                done(elementsLoaded);
            });
          });
        } else {
          if (elements) {
            injectElement(elements, evalScripts, pngFallback, function(svg) {
              if (eachCallback && typeof eachCallback === "function")
                eachCallback(svg);
              if (done)
                done(1);
              elements = null;
            });
          } else {
            if (done)
              done(0);
          }
        }
      };
      if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = exports = SVGInjector;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return SVGInjector;
        });
      } else if (typeof window2 === "object") {
        window2.SVGInjector = SVGInjector;
      }
    })(window, document);
  }
});
export default require_svg_injector();
/*! Bundled license information:

svg-injector/svg-injector.js:
  (**
   * SVGInjector v1.1.3 - Fast, caching, dynamic inline SVG DOM injection library
   * https://github.com/iconic/SVGInjector
   *
   * Copyright (c) 2014-2015 Waybury <hello@waybury.com>
   * @license MIT
   *)
*/
//# sourceMappingURL=svg-injector.js.map
