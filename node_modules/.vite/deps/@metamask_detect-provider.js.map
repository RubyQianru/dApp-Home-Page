{
  "version": 3,
  "sources": ["../../@metamask/detect-provider/src/index.ts"],
  "sourcesContent": ["interface MetaMaskEthereumProvider {\n  isMetaMask?: boolean;\n  once(eventName: string | symbol, listener: (...args: any[]) => void): this;\n  on(eventName: string | symbol, listener: (...args: any[]) => void): this;\n  off(eventName: string | symbol, listener: (...args: any[]) => void): this;\n  addListener(eventName: string | symbol, listener: (...args: any[]) => void): this;\n  removeListener(eventName: string | symbol, listener: (...args: any[]) => void): this;\n  removeAllListeners(event?: string | symbol): this;\n}\n\ninterface Window {\n  ethereum?: MetaMaskEthereumProvider;\n}\n\nexport = detectEthereumProvider;\n\n/**\n * Returns a Promise that resolves to the value of window.ethereum if it is\n * set within the given timeout, or null.\n * The Promise will not reject, but an error will be thrown if invalid options\n * are provided.\n *\n * @param options - Options bag.\n * @param options.mustBeMetaMask - Whether to only look for MetaMask providers.\n * Default: false\n * @param options.silent - Whether to silence console errors. Does not affect\n * thrown errors. Default: false\n * @param options.timeout - Milliseconds to wait for 'ethereum#initialized' to\n * be dispatched. Default: 3000\n * @returns A Promise that resolves with the Provider if it is detected within\n * given timeout, otherwise null.\n */\nfunction detectEthereumProvider<T = MetaMaskEthereumProvider>({\n  mustBeMetaMask = false,\n  silent = false,\n  timeout = 3000,\n} = {}): Promise<T | null> {\n\n  _validateInputs();\n\n  let handled = false;\n\n  return new Promise((resolve) => {\n    if ((window as Window).ethereum) {\n\n      handleEthereum();\n\n    } else {\n\n      window.addEventListener(\n        'ethereum#initialized',\n        handleEthereum,\n        { once: true },\n      );\n\n      setTimeout(() => {\n        handleEthereum();\n      }, timeout);\n    }\n\n    function handleEthereum() {\n\n      if (handled) {\n        return;\n      }\n      handled = true;\n\n      window.removeEventListener('ethereum#initialized', handleEthereum);\n\n      const { ethereum } = window as Window;\n\n      if (ethereum && (!mustBeMetaMask || ethereum.isMetaMask)) {\n        resolve(ethereum as unknown as T);\n      } else {\n\n        const message = mustBeMetaMask && ethereum\n          ? 'Non-MetaMask window.ethereum detected.'\n          : 'Unable to detect window.ethereum.';\n\n        !silent && console.error('@metamask/detect-provider:', message);\n        resolve(null);\n      }\n    }\n  });\n\n  function _validateInputs() {\n    if (typeof mustBeMetaMask !== 'boolean') {\n      throw new Error(`@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.`);\n    }\n    if (typeof silent !== 'boolean') {\n      throw new Error(`@metamask/detect-provider: Expected option 'silent' to be a boolean.`);\n    }\n    if (typeof timeout !== 'number') {\n      throw new Error(`@metamask/detect-provider: Expected option 'timeout' to be a number.`);\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;AAgCA,aAAS,uBAAqD,EAC5D,iBAAiB,OACjB,SAAS,OACT,UAAU,IAAI,IACZ,CAAA,GAAE;AAEJ,sBAAe;AAEf,UAAI,UAAU;AAEd,aAAO,IAAI,QAAQ,CAAC,YAAW;AAC7B,YAAK,OAAkB,UAAU;AAE/B,yBAAc;eAET;AAEL,iBAAO,iBACL,wBACA,gBACA,EAAE,MAAM,KAAI,CAAE;AAGhB,qBAAW,MAAK;AACd,2BAAc;UAChB,GAAG,OAAO;;AAGZ,iBAAS,iBAAc;AAErB,cAAI,SAAS;AACX;;AAEF,oBAAU;AAEV,iBAAO,oBAAoB,wBAAwB,cAAc;AAEjE,gBAAM,EAAE,SAAQ,IAAK;AAErB,cAAI,aAAa,CAAC,kBAAkB,SAAS,aAAa;AACxD,oBAAQ,QAAwB;iBAC3B;AAEL,kBAAM,UAAU,kBAAkB,WAC9B,2CACA;AAEJ,aAAC,UAAU,QAAQ,MAAM,8BAA8B,OAAO;AAC9D,oBAAQ,IAAI;;QAEhB;MACF,CAAC;AAED,eAAS,kBAAe;AACtB,YAAI,OAAO,mBAAmB,WAAW;AACvC,gBAAM,IAAI,MAAM,8EAA8E;;AAEhG,YAAI,OAAO,WAAW,WAAW;AAC/B,gBAAM,IAAI,MAAM,sEAAsE;;AAExF,YAAI,OAAO,YAAY,UAAU;AAC/B,gBAAM,IAAI,MAAM,sEAAsE;;MAE1F;IACF;AAlFA,WAAA,UAAS;;;",
  "names": []
}
