{"version":3,"file":"metamask-sdk-communication-layer.js","sources":["../../../src/Analytics.ts","../../../src/ECIES.ts","../../../src/config.ts","../../../src/services/RemoteCommunication/ChannelManager/clean.ts","../../../src/types/ConnectionStatus.ts","../../../src/types/EventType.ts","../../../src/types/InternalEventType.ts","../../../src/types/KeyExchangeMessageType.ts","../../../src/types/MessageType.ts","../../../src/KeyExchange.ts","../../../src/utils/wait.ts","../../../src/services/SocketService/ConnectionManager/reconnectSocket.ts","../../../src/services/SocketService/EventListeners/handleDisconnect.ts","../../../src/services/SocketService/ConnectionManager/checkFocusAndReconnect.ts","../../../src/services/SocketService/ChannelManager/setupChannelListeners.ts","../../../src/services/SocketService/EventListeners/handleClientsConnected.ts","../../../src/services/SocketService/EventListeners/handleChannelCreated.ts","../../../src/services/SocketService/EventListeners/handlesClientsDisconnected.ts","../../../src/services/SocketService/EventListeners/handleMessage.ts","../../../src/services/SocketService/ChannelManager/checkSameId.ts","../../../src/services/SocketService/EventListeners/handleClientsWaitingToJoin.ts","../../../src/services/SocketService/EventListeners/handleKeyInfo.ts","../../../src/services/SocketService/EventListeners/handleKeysExchanged.ts","../../../src/services/SocketService/MessageHandlers/handleSendMessage.ts","../../../src/services/SocketService/KeysManager/handleKeyHandshake.ts","../../../src/services/SocketService/KeysManager/validateKeyExchange.ts","../../../src/services/SocketService/MessageHandlers/trackRpcMethod.ts","../../../src/services/SocketService/MessageHandlers/encryptAndSendMessage.ts","../../../src/services/SocketService/MessageHandlers/handleRpcReplies.ts","../../../src/SocketService.ts","../../../src/services/SocketService/KeysManager/resetKeys.ts","../../../src/services/SocketService/ChannelManager/createChannel.ts","../../../src/services/SocketService/ConnectionManager/connectToChannel.ts","../../../src/services/SocketService/KeysManager/keyCheck.ts","../../../src/services/SocketService/ConnectionManager/ping.ts","../../../src/services/SocketService/ConnectionManager/pause.ts","../../../src/services/SocketService/ConnectionManager/resume.ts","../../../src/services/SocketService/ConnectionManager/disconnect.ts","../../../src/types/CommunicationLayerPreference.ts","../../../src/types/PlatformType.ts","../../../src/types/TrackingEvent.ts","../../../src/types/AutoConnectType.ts","../../../src/services/RemoteCommunication/EventListeners/handleAuthorizedEvent.ts","../../../src/services/RemoteCommunication/EventListeners/handleChannelCreatedEvent.ts","../../../src/services/RemoteCommunication/EventListeners/handleClientsConnectedEvent.ts","../../../src/services/RemoteCommunication/EventListeners/handleClientsDisconnectedEvent.ts","../../../src/services/RemoteCommunication/EventListeners/handleClientsWaitingEvent.ts","../../../src/services/RemoteCommunication/EventListeners/handleKeysExchangedEvent.ts","../../../src/services/RemoteCommunication/StateManger/setLastActiveDate.ts","../../../src/services/RemoteCommunication/MessageHandlers/onCommunicationLayerMessage.ts","../../../src/services/RemoteCommunication/MessageHandlers/handleWalletInfoMessage.ts","../../../src/services/RemoteCommunication/MessageHandlers/handleTerminateMessage.ts","../../../src/services/RemoteCommunication/MessageHandlers/handlePauseMessage.ts","../../../src/services/RemoteCommunication/MessageHandlers/handleReadyMessage.ts","../../../src/services/RemoteCommunication/MessageHandlers/handleOtpMessage.ts","../../../src/services/RemoteCommunication/MessageHandlers/handleAuthorizedMessage.ts","../../../src/services/RemoteCommunication/MessageHandlers/handleOriginatorInfoMessage.ts","../../../src/services/RemoteCommunication/MessageHandlers/sendMessage.ts","../../../src/services/RemoteCommunication/ConnectionManager/handleAuthorization.ts","../../../src/services/RemoteCommunication/EventListeners/handleMessageEvent.ts","../../../src/services/RemoteCommunication/EventListeners/handleSocketReconnectEvent.ts","../../../src/services/RemoteCommunication/EventListeners/handleSocketDisconnectedEvent.ts","../../../src/services/RemoteCommunication/ConnectionManager/disconnect.ts","../../../src/RemoteCommunication.ts","../../../src/services/RemoteCommunication/ConnectionManager/initCommunicationLayer.ts","../../../src/services/RemoteCommunication/ConnectionManager/originatorSessionConnect.ts","../../../src/services/RemoteCommunication/ChannelManager/generateChannelIdConnect.ts","../../../src/services/RemoteCommunication/ConnectionManager/connectToChannel.ts","../../../src/services/RemoteCommunication/StorageManager/testStorage.ts","../../../src/services/RemoteCommunication/ConnectionManager/resume.ts"],"sourcesContent":["import crossFetch from 'cross-fetch';\nimport { CommunicationLayerPreference } from './types/CommunicationLayerPreference';\nimport { OriginatorInfo } from './types/OriginatorInfo';\nimport { TrackingEvents } from './types/TrackingEvent';\n\nexport interface AnaliticsProps {\n  id: string;\n  event: TrackingEvents;\n  originationInfo?: OriginatorInfo;\n  commLayer?: CommunicationLayerPreference;\n  sdkVersion?: string;\n  commLayerVersion: string;\n  walletVersion?: string;\n}\n\nexport const SendAnalytics = async (\n  parameters: AnaliticsProps,\n  socketServerUrl: string,\n) => {\n  const serverUrl = socketServerUrl.endsWith('/')\n    ? `${socketServerUrl}debug`\n    : `${socketServerUrl}/debug`;\n  const body = JSON.stringify(parameters);\n\n  const response = await crossFetch(serverUrl, {\n    method: 'POST',\n    headers: {\n      // eslint-disable-next-line prettier/prettier\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    },\n    body,\n  });\n\n  // TODO error management when request fails\n  const text = await response.text();\n  return text;\n};\n","import { Buffer } from 'buffer';\nimport { decrypt, encrypt, PrivateKey } from 'eciesjs';\n\n/**\n * These properties are optional and should only be used during development for debugging purposes.\n */\nexport interface ECIESProps {\n  debug?: boolean;\n  pkey?: string;\n}\n\n/**\n * Class that exposes methods to generate and compute\n * Elliptic Curve Integrated Encryption Scheme (ECIES) for key exchange and symmetric encryption/decryption\n *\n * It also exposes encryption/decryption methods that are used\n * by the communication layer to encrypt/decrypt in/out data\n * The encryption/decryption is made using a symmetric key generated from the ECIES key exchange\n */\nexport class ECIES {\n  private ecies: PrivateKey;\n\n  private enabled = true;\n\n  private debug = false;\n\n  constructor(props?: ECIESProps) {\n    if (props?.debug) {\n      this.debug = props.debug;\n    }\n\n    if (props?.pkey) {\n      this.ecies = PrivateKey.fromHex(props.pkey);\n    } else {\n      this.ecies = new PrivateKey();\n    }\n\n    if (this.debug) {\n      console.info(`[ECIES] initialized secret: `, this.ecies.toHex());\n      console.info(\n        `[ECIES] initialized public: `,\n        this.ecies.publicKey.toHex(),\n      );\n      console.info(`[ECIES] init with`, this);\n    }\n  }\n\n  /**\n   * Creates new ECIES instance\n   *\n   * @returns - Generates ECIES instance\n   */\n  generateECIES(): void {\n    this.ecies = new PrivateKey();\n  }\n\n  /**\n   * Returns ECIES instance public key\n   *\n   * @returns - public key in base64 format\n   */\n  getPublicKey(): string {\n    return this.ecies.publicKey.toHex();\n  }\n\n  /**\n   * Encrypts a data message using the public key of the side to encrypt data for\n   *\n   * @param {string} data - data string to be encrypted\n   * @param {string} otherPublicKey - public key of the side to encrypt data for\n   * @returns - encrypted string in base64\n   */\n  encrypt(data: string, otherPublicKey: string): string {\n    let encryptedString = data;\n    if (this.enabled) {\n      try {\n        if (this.debug) {\n          console.debug(\n            `ECIES::encrypt() using otherPublicKey`,\n            otherPublicKey,\n          );\n        }\n        const payload = Buffer.from(data);\n        const encryptedData = encrypt(otherPublicKey, payload);\n        encryptedString = Buffer.from(encryptedData).toString('base64');\n      } catch (err) {\n        if (this.debug) {\n          console.error(`error encrypt:`, err);\n          console.error(`private: `, this.ecies.toHex());\n          console.error('data: ', data);\n          console.error(`otherkey: `, otherPublicKey);\n        }\n        throw err;\n      }\n    }\n    return encryptedString;\n  }\n\n  /**\n   * Decrypts a data message using the instance private key\n   *\n   * @param {string} encryptedData - base64 data string to be decrypted\n   * @returns - decrypted data || error message\n   */\n  decrypt(encryptedData: string): string {\n    let decryptedString = encryptedData;\n    if (this.enabled) {\n      try {\n        if (this.debug) {\n          console.debug(\n            `ECIES::decrypt() using privateKey`,\n            this.ecies.toHex(),\n          );\n        }\n        const payload = Buffer.from(encryptedData.toString(), 'base64');\n        const decrypted = decrypt(this.ecies.toHex(), payload);\n\n        decryptedString = decrypted.toString();\n      } catch (error) {\n        if (this.debug) {\n          console.error(`error decrypt`, error);\n          console.error(`private: `, this.ecies.toHex());\n          console.error(`encryptedData: `, encryptedData);\n        }\n        throw error;\n      }\n    }\n\n    return decryptedString;\n  }\n\n  getKeyInfo(): { private: string; public: string } {\n    return {\n      private: this.ecies.toHex(),\n      public: this.ecies.publicKey.toHex(),\n    };\n  }\n\n  toString() {\n    console.debug(`ECIES::toString()`, this.getKeyInfo());\n  }\n}\n","export const DEFAULT_SERVER_URL =\n  'https://metamask-sdk-socket.metafi.codefi.network/';\nexport const DEFAULT_SOCKET_TRANSPORTS = ['polling', 'websocket'];\nexport const MIN_IN_MS = 1000 * 60;\nexport const HOUR_IN_MS = MIN_IN_MS * 60;\nexport const DAY_IN_MS = HOUR_IN_MS * 24;\nexport const DEFAULT_SESSION_TIMEOUT_MS = 7 * DAY_IN_MS;\n\n// time upon which we wait for a metamask reocnnection before creating a new channel\nexport const CHANNEL_MAX_WAITING_TIME = 3 * 1000; // 3 seconds\n\nexport const MAX_RPC_WAIT_TIME = 5 * 60 * 1000; // 5 minutes\n\nexport const RPC_METHODS = {\n  METAMASK_GETPROVIDERSTATE: 'metamask_getProviderState',\n  ETH_REQUESTACCOUNTS: 'eth_requestAccounts',\n};\n","import { RemoteCommunicationState } from '../../../RemoteCommunication';\n\n/**\n * Cleans the state of the RemoteCommunication, resetting various properties to their default values.\n *\n * @param state Current state of the RemoteCommunication class instance.\n * @returns void\n */\nexport function clean(state: RemoteCommunicationState) {\n  const { debug, context } = state;\n  if (debug) {\n    console.debug(`RemoteCommunication::${context}::clean()`);\n  }\n\n  state.channelConfig = undefined;\n  state.ready = false;\n  state.originatorConnectStarted = false;\n}\n","export enum ConnectionStatus {\n  // DISCONNECTED: counterparty is disconnected\n  DISCONNECTED = 'disconnected',\n  // WAITING: means connected to the websocket but the counterparty (MetaMask or Dapps) isn't.\n  WAITING = 'waiting',\n  // TIMEOUT: means auto connect didn't establish link within given timeout\n  TIMEOUT = 'timeout',\n  // LINKED: is connected after handshake, using a different verb to avoid confusion to just being connected to the websocket and waiting for counterpart.\n  // LINKED is set when receiving 'READY' message from counterpart.\n  LINKED = 'linked',\n  // PAUSED:\n  PAUSED = 'paused',\n  // TERMINATED: if a user manually disconnect the session.\n  TERMINATED = 'terminated',\n}\n","export enum EventType {\n  // emitted everytime the current step is updated\n  KEY_INFO = 'key_info',\n  SERVICE_STATUS = 'service_status',\n  PROVIDER_UPDATE = 'provider_update',\n  RPC_UPDATE = 'rpc_update',\n  KEYS_EXCHANGED = 'keys_exchanged',\n  JOIN_CHANNEL = 'join_channel',\n  CHANNEL_CREATED = 'channel_created',\n  CLIENTS_CONNECTED = 'clients_connected',\n  CLIENTS_DISCONNECTED = 'clients_disconnected',\n  CLIENTS_WAITING = 'clients_waiting',\n  CLIENTS_READY = 'clients_ready',\n  SOCKET_DISCONNECTED = 'socket_disconnected',\n  // socket reconnect should only happen on ios mobile\n  SOCKET_RECONNECT = 'socket_reconnect',\n  OTP = 'otp',\n  // used to trigger RPC call from comm layer, usually only used for backward compatibility\n  SDK_RPC_CALL = 'sdk_rpc_call',\n  // event emitted when the connection is authorized on the wallet.\n  AUTHORIZED = 'authorized',\n  CONNECTION_STATUS = 'connection_status',\n  MESSAGE = 'message',\n  TERMINATE = 'terminate',\n}\n","export enum InternalEventType {\n  /**\n   * KEY_EXCHANGE is used between Communication layer and KeyExchange Layer\n   */\n  KEY_EXCHANGE = 'key_exchange',\n}\n","export enum KeyExchangeMessageType {\n  KEY_HANDSHAKE_START = 'key_handshake_start',\n  KEY_HANDSHAKE_CHECK = 'key_handshake_check',\n  KEY_HANDSHAKE_SYN = 'key_handshake_SYN',\n  KEY_HANDSHAKE_SYNACK = 'key_handshake_SYNACK',\n  KEY_HANDSHAKE_ACK = 'key_handshake_ACK',\n  KEY_HANDSHAKE_NONE = 'none',\n}\n","export enum MessageType {\n  // TERMINATE: used to inform the other side that connection is terminating and channel id needs to be changed.\n  TERMINATE = 'terminate',\n  ANSWER = 'answer',\n  OFFER = 'offer',\n  CANDIDATE = 'candidate',\n  JSONRPC = 'jsonrpc',\n  WALLET_INFO = 'wallet_info',\n  ORIGINATOR_INFO = 'originator_info',\n  PAUSE = 'pause',\n  OTP = 'otp',\n  /**\n   * Sent from the wallet when the user has approved the connection.\n   */\n  AUTHORIZED = 'authorized',\n  /**\n   * Used for debugging purpose and check channel validity.\n   */\n  PING = 'ping',\n  // READY is sent when the connection is linked\n  READY = 'ready',\n}\n","import { EventEmitter2 } from 'eventemitter2';\nimport { ECIES, ECIESProps } from './ECIES';\nimport { CommunicationLayer } from './types/CommunicationLayer';\nimport { CommunicationLayerMessage } from './types/CommunicationLayerMessage';\nimport { EventType } from './types/EventType';\nimport { InternalEventType } from './types/InternalEventType';\nimport { KeyExchangeMessageType } from './types/KeyExchangeMessageType';\nimport { KeyInfo } from './types/KeyInfo';\nimport { CommunicationLayerLoggingOptions } from './types/LoggingOptions';\n\nexport interface KeyExchangeProps {\n  communicationLayer: CommunicationLayer;\n  otherPublicKey?: string;\n  sendPublicKey: boolean;\n  context: string;\n  logging?: CommunicationLayerLoggingOptions;\n  ecies?: ECIESProps;\n}\n\nexport class KeyExchange extends EventEmitter2 {\n  private keysExchanged = false;\n\n  private myECIES: ECIES;\n\n  private otherPublicKey?: string;\n\n  private communicationLayer: CommunicationLayer;\n\n  private myPublicKey: string;\n\n  private step = KeyExchangeMessageType.KEY_HANDSHAKE_NONE;\n\n  private context: string;\n\n  private debug = false;\n\n  constructor({\n    communicationLayer,\n    otherPublicKey,\n    context,\n    ecies,\n    logging,\n  }: KeyExchangeProps) {\n    super();\n\n    this.context = context;\n    this.myECIES = new ECIES({ ...ecies, debug: logging?.eciesLayer });\n    this.communicationLayer = communicationLayer;\n    this.myPublicKey = this.myECIES.getPublicKey();\n    this.debug = logging?.keyExchangeLayer === true;\n\n    if (otherPublicKey) {\n      this.setOtherPublicKey(otherPublicKey);\n    }\n\n    this.communicationLayer.on(\n      InternalEventType.KEY_EXCHANGE,\n      this.onKeyExchangeMessage.bind(this),\n    );\n  }\n\n  public onKeyExchangeMessage(keyExchangeMsg: {\n    message: CommunicationLayerMessage;\n  }) {\n    if (this.debug) {\n      console.debug(\n        `KeyExchange::${this.context}::onKeyExchangeMessage() keysExchanged=${this.keysExchanged}`,\n        keyExchangeMsg,\n      );\n    }\n\n    const { message } = keyExchangeMsg;\n    if (this.keysExchanged) {\n      if (this.debug) {\n        console.log(\n          `KeyExchange::${this.context}::onKeyExchangeMessage received handshake while already exchanged. step=${this.step} otherPubKey=${this.otherPublicKey}`,\n        );\n      }\n      // FIXME check if correct way / when is it really happening?\n      // return;\n    }\n\n    if (message.type === KeyExchangeMessageType.KEY_HANDSHAKE_SYN) {\n      // TODO check for either NONE or ACK\n      this.checkStep([\n        KeyExchangeMessageType.KEY_HANDSHAKE_NONE,\n        KeyExchangeMessageType.KEY_HANDSHAKE_ACK,\n      ]);\n\n      if (this.debug) {\n        console.debug(`KeyExchange::KEY_HANDSHAKE_SYN`, message);\n      }\n\n      if (message.pubkey) {\n        this.setOtherPublicKey(message.pubkey);\n      }\n\n      this.communicationLayer.sendMessage({\n        type: KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK,\n        pubkey: this.myPublicKey,\n      });\n\n      this.step = KeyExchangeMessageType.KEY_HANDSHAKE_ACK;\n      this.emit(EventType.KEY_INFO, this.step);\n    } else if (message.type === KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK) {\n      // TODO currently key exchange start from both side so step may be on both SYNACK or ACK.\n      this.checkStep([\n        KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK,\n        KeyExchangeMessageType.KEY_HANDSHAKE_NONE,\n      ]);\n\n      if (this.debug) {\n        console.debug(`KeyExchange::KEY_HANDSHAKE_SYNACK`);\n      }\n\n      if (message.pubkey) {\n        this.setOtherPublicKey(message.pubkey);\n      }\n\n      this.communicationLayer.sendMessage({\n        type: KeyExchangeMessageType.KEY_HANDSHAKE_ACK,\n      });\n      this.keysExchanged = true;\n      // Reset step value for next exchange.\n      this.step = KeyExchangeMessageType.KEY_HANDSHAKE_NONE;\n      this.emit(EventType.KEYS_EXCHANGED);\n    } else if (message.type === KeyExchangeMessageType.KEY_HANDSHAKE_ACK) {\n      if (this.debug) {\n        console.debug(\n          `KeyExchange::KEY_HANDSHAKE_ACK set keysExchanged to true!`,\n        );\n      }\n\n      this.checkStep([\n        KeyExchangeMessageType.KEY_HANDSHAKE_ACK,\n        KeyExchangeMessageType.KEY_HANDSHAKE_NONE,\n      ]);\n      this.keysExchanged = true;\n      // Reset step value for next exchange.\n      this.step = KeyExchangeMessageType.KEY_HANDSHAKE_NONE;\n      this.emit(EventType.KEYS_EXCHANGED);\n    }\n  }\n\n  resetKeys(ecies?: ECIESProps) {\n    this.clean();\n    this.myECIES = new ECIES(ecies);\n  }\n\n  clean(): void {\n    if (this.debug) {\n      console.debug(\n        `KeyExchange::${this.context}::clean reset handshake state`,\n      );\n    }\n    this.step = KeyExchangeMessageType.KEY_HANDSHAKE_NONE;\n    this.emit(EventType.KEY_INFO, this.step);\n    this.keysExchanged = false;\n    // Do not uncomment next line otherwise it breaks old sdk compatibility.\n    // this.otherPublicKey = undefined;\n  }\n\n  start({\n    isOriginator,\n    force,\n  }: {\n    isOriginator: boolean;\n    force?: boolean;\n  }): void {\n    if (this.debug) {\n      console.debug(\n        `KeyExchange::${this.context}::start isOriginator=${isOriginator} step=${this.step} force=${force} keysExchanged=${this.keysExchanged}`,\n      );\n    }\n\n    if (!isOriginator) {\n      // force is used to redo keyexchange even if already exchanged.\n      if (!this.keysExchanged || force === true) {\n        // Ask to start exchange only if not already in progress\n        this.communicationLayer.sendMessage({\n          type: KeyExchangeMessageType.KEY_HANDSHAKE_START,\n        });\n        this.clean();\n      } else if (this.debug) {\n        console.debug(\n          `KeyExchange::start don't send KEY_HANDSHAKE_START -- exchange already done.`,\n        );\n      }\n\n      return;\n    }\n\n    if (\n      (this.keysExchanged ||\n        this.step !== KeyExchangeMessageType.KEY_HANDSHAKE_NONE) &&\n      !force\n    ) {\n      // Key exchange can be restarted if the wallet ask for a new key.\n      if (this.debug) {\n        console.debug(\n          `KeyExchange::${this.context}::start -- key exchange already ${\n            this.keysExchanged ? 'done' : 'in progress'\n          } -- aborted.`,\n          this.step,\n        );\n      }\n      return;\n    }\n\n    if (this.debug) {\n      console.debug(\n        `KeyExchange::${this.context}::start -- start key exchange (force=${force}) -- step=${this.step}`,\n        this.step,\n      );\n    }\n\n    this.clean();\n    this.step = KeyExchangeMessageType.KEY_HANDSHAKE_SYNACK;\n    this.emit(EventType.KEY_INFO, this.step);\n    // From v0.2.0, we Always send the public key because exchange can be restarted at any time.\n    this.communicationLayer.sendMessage({\n      type: KeyExchangeMessageType.KEY_HANDSHAKE_SYN,\n      pubkey: this.myPublicKey,\n    });\n  }\n\n  checkStep(stepList: string[]): void {\n    if (stepList.length > 0 && stepList.indexOf(this.step.toString()) === -1) {\n      throw new Error(`Wrong Step \"${this.step}\" not within ${stepList}`);\n    }\n  }\n\n  setKeysExchanged(keysExchanged: boolean) {\n    this.keysExchanged = keysExchanged;\n  }\n\n  areKeysExchanged() {\n    return this.keysExchanged;\n  }\n\n  getMyPublicKey() {\n    return this.myPublicKey;\n  }\n\n  getOtherPublicKey() {\n    return this.otherPublicKey;\n  }\n\n  setOtherPublicKey(otherPubKey: string) {\n    if (this.debug) {\n      console.debug(`KeyExchange::setOtherPubKey()`, otherPubKey);\n    }\n    this.otherPublicKey = otherPubKey;\n  }\n\n  encryptMessage(message: string): string {\n    if (!this.otherPublicKey) {\n      throw new Error(\n        'encryptMessage: Keys not exchanged - missing otherPubKey',\n      );\n    }\n    return this.myECIES.encrypt(message, this.otherPublicKey);\n  }\n\n  decryptMessage(message: string): string {\n    if (!this.otherPublicKey) {\n      throw new Error(\n        'decryptMessage: Keys not exchanged - missing otherPubKey',\n      );\n    }\n\n    return this.myECIES.decrypt(message);\n  }\n\n  getKeyInfo(): KeyInfo {\n    return {\n      ecies: { ...this.myECIES.getKeyInfo(), otherPubKey: this.otherPublicKey },\n      step: this.step,\n      keysExchanged: this.areKeysExchanged(),\n    };\n  }\n\n  toString() {\n    const buf = {\n      keyInfo: this.getKeyInfo(),\n      keysExchanged: this.keysExchanged,\n      step: this.step,\n    };\n    return JSON.stringify(buf);\n  }\n}\n","import { MAX_RPC_WAIT_TIME } from '../config';\nimport { RPCMethodCache, RPCMethodResult } from '../SocketService';\n\nexport const wait = (ms: number) => {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n};\n\nexport const waitForRpc = async (\n  rpcId: string,\n  rpc: RPCMethodCache,\n  interval = 200, // 200ms\n): Promise<RPCMethodResult> => {\n  let result;\n  const startTime = Date.now();\n\n  let hasTimedout = false;\n\n  while (!hasTimedout) {\n    const waitTime = Date.now() - startTime;\n    hasTimedout = waitTime > MAX_RPC_WAIT_TIME;\n\n    // console.debug(`Waiting for RPC ${rpcId}... (${waitTime}ms)`);\n    result = rpc[rpcId];\n    if (result.elapsedTime !== undefined) {\n      return result;\n    }\n    await wait(interval);\n  }\n  throw new Error(`RPC ${rpcId} timed out`);\n};\n","import { SocketService } from '../../../SocketService';\nimport { EventType } from '../../../types/EventType';\nimport { wait } from '../../../utils/wait';\n\n/**\n * Attempts to reconnect the socket after a disconnection.\n * It first waits for a brief delay to prevent potential issues, then checks if the socket is not already connected.\n * If the socket is not connected, it sets the `resumed` state to true, reconnects the socket, and emits a SOCKET_RECONNECT event.\n * It also emits a JOIN_CHANNEL event to rejoin the channel.\n *\n * @param instance The current instance of the SocketService.\n */\nexport const reconnectSocket = async (instance: SocketService) => {\n  if (instance.state.debug) {\n    console.debug(\n      `SocketService::connectAgain instance.state.socket?.connected=${instance.state.socket?.connected} trying to reconnect after socketio disconnection`,\n      instance,\n    );\n  }\n\n  // Add delay to prevent IOS error\n  // https://stackoverflow.com/questions/53297188/afnetworking-error-53-during-attempted-background-fetch\n  await wait(200);\n\n  if (!instance.state.socket?.connected) {\n    instance.state.resumed = true;\n    instance.state.socket?.connect();\n\n    instance.emit(EventType.SOCKET_RECONNECT);\n    instance.state.socket?.emit(\n      EventType.JOIN_CHANNEL,\n      instance.state.channelId,\n      `${instance.state.context}connect_again`,\n    );\n  }\n\n  // wait again to make sure socket status is updated.\n  await wait(100);\n  return instance.state.socket?.connected;\n};\n","import { SocketService } from '../../../SocketService';\nimport { EventType } from '../../../types/EventType';\nimport { checkFocusAndReconnect } from '../ConnectionManager';\n\n/**\n * Returns a handler function to handle the 'disconnect' event.\n * This handler checks whether the disconnection was manual or due to other reasons.\n * If it wasn't a manual disconnect, it emits the SOCKET_DISCONNECTED event and attempts to reconnect.\n *\n * @param instance The current instance of the SocketService.\n * @returns {Function} A handler function for the 'disconnect' event.\n */\nexport function handleDisconnect(instance: SocketService) {\n  return (reason: string) => {\n    if (instance.state.debug) {\n      console.debug(\n        `SocketService::on 'disconnect' manualDisconnect=${instance.state.manualDisconnect}`,\n        reason,\n      );\n    }\n\n    if (!instance.state.manualDisconnect) {\n      /**\n       * Used for web in case of socket io disconnection.\n       * Always try to recover the connection.\n       *\n       * 'disconnect' event also happens on RN after app is in background for ~30seconds.\n       * The reason is will be 'transport error'.\n       * instance creates an issue that the user needs to reply a provider query within 30 seconds.\n       *\n       * FIXME: is there a way to address a slow (>30s) provider query reply.\n       */\n      instance.emit(EventType.SOCKET_DISCONNECTED);\n      checkFocusAndReconnect(instance);\n    }\n  };\n}\n","import { SocketService } from '../../../SocketService';\nimport { reconnectSocket } from './reconnectSocket';\n\n/**\n * Checks the focus status of the document and triggers socket reconnection if necessary.\n * If the document has focus, it immediately calls the reconnectSocket function to attempt reconnection.\n * If the document doesn't have focus, it sets up a focus event listener to trigger reconnection once the document regains focus.\n *\n * @param instance The current instance of the SocketService.\n */\nexport function checkFocusAndReconnect(instance: SocketService) {\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return;\n  }\n\n  if (instance.state.debug) {\n    console.debug(\n      `SocketService::checkFocus hasFocus=${document.hasFocus()}`,\n      instance,\n    );\n  }\n\n  if (document.hasFocus()) {\n    reconnectSocket(instance)\n      .then((success) => {\n        if (instance.state.debug) {\n          console.debug(\n            `SocketService::checkFocus reconnectSocket success=${success}`,\n            instance,\n          );\n        }\n      })\n      .catch((err) => {\n        console.error(\n          `SocketService::checkFocus Error reconnecting socket`,\n          err,\n        );\n      });\n  } else {\n    window.addEventListener(\n      'focus',\n      () => {\n        reconnectSocket(instance).catch((err) => {\n          console.error(\n            `SocketService::checkFocus Error reconnecting socket`,\n            err,\n          );\n        });\n      },\n      {\n        once: true,\n      },\n    );\n  }\n}\n","import { SocketService } from '../../../SocketService';\nimport { EventType } from '../../../types/EventType';\nimport {\n  handleChannelCreated,\n  handleClientsConnected,\n  handleClientsWaitingToJoin,\n  handleDisconnect,\n  handleKeyInfo,\n  handleKeysExchanged,\n  handleMessage,\n  handlesClientsDisconnected,\n} from '../EventListeners';\n\nconst channelEventListenerMap = [\n  {\n    event: 'clients_connected',\n    handler: handleClientsConnected,\n  },\n  {\n    event: 'channel_created',\n    handler: handleChannelCreated,\n  },\n  {\n    event: 'clients_disconnected',\n    handler: handlesClientsDisconnected,\n  },\n  { event: 'message', handler: handleMessage },\n  {\n    event: 'clients_waiting_to_join',\n    handler: handleClientsWaitingToJoin,\n  },\n];\n\nconst keyExchangeEventListenerMap = [\n  {\n    event: EventType.KEY_INFO,\n    handler: handleKeyInfo,\n  },\n  {\n    event: EventType.KEYS_EXCHANGED,\n    handler: handleKeysExchanged,\n  },\n];\n\n/**\n * Sets up event listeners for a SocketService instance associated with a specific channel.\n * If debugging is enabled, a debug message is logged indicating the setup process.\n * Event listeners are added to the socket for events defined in the\n * `socketEventListenerMap`, `channelEventListenerMap`, and `keyExchangeEventListenerMap`.\n *\n * @param instance The current instance of the SocketService.\n * @param channelId The ID of the channel associated with the listeners.\n */\nexport function setupChannelListeners(\n  instance: SocketService,\n  channelId: string,\n) {\n  if (instance.state.debug) {\n    console.debug(\n      `SocketService::${instance.state.context}::setupChannelListener setting socket listeners for channel ${channelId}...`,\n    );\n  }\n\n  const { socket } = instance.state;\n  const { keyExchange } = instance.state;\n\n  if (instance.state.setupChannelListeners) {\n    console.warn(\n      `SocketService::${instance.state.context}::setupChannelListener socket listeners already set up for channel ${channelId}`,\n    );\n  }\n\n  // Only available for the originator -- used for connection recovery\n  if (socket && instance.state.isOriginator) {\n    if (instance.state.debug) {\n      // TODO remove all the handleSocker* functions\n      // They are not required since it is managed via the handleDisconnect function\n      socket?.io.on('error', (error) => {\n        console.debug(\n          `SocketService::${instance.state.context}::setupChannelListener socket event=error`,\n          error,\n        );\n        // return handleSocketError(instance)(error);\n      });\n\n      socket?.io.on('reconnect', (attempt) => {\n        console.debug(\n          `SocketService::${instance.state.context}::setupChannelListener socket event=reconnect`,\n          attempt,\n        );\n      });\n\n      socket?.io.on('reconnect_error', (error) => {\n        console.debug(\n          `SocketService::${instance.state.context}::setupChannelListener socket event=reconnect_error`,\n          error,\n        );\n        // return handleReconnectError(instance)(error);\n      });\n\n      socket?.io.on('reconnect_failed', () => {\n        console.debug(\n          `SocketService::${instance.state.context}::setupChannelListener socket event=reconnect_failed`,\n        );\n        // return handleReconnectFailed(instance)();\n      });\n\n      socket?.io.on('ping', () => {\n        console.debug(\n          `SocketService::${instance.state.context}::setupChannelListener socket event=ping`,\n        );\n        // return handlePing(instance)();\n      });\n    }\n\n    socket?.on('disconnect', (reason: string) => {\n      console.log(\n        `MetaMaskSDK socket disconnected '${reason}' begin recovery...`,\n      );\n      return handleDisconnect(instance)(reason);\n    });\n  }\n\n  channelEventListenerMap.forEach(({ event, handler }) => {\n    const fullEventName = `${event}-${channelId}`;\n    socket?.on(fullEventName, handler(instance, channelId));\n  });\n\n  keyExchangeEventListenerMap.forEach(({ event, handler }) => {\n    keyExchange?.on(event, handler(instance));\n  });\n\n  instance.state.setupChannelListeners = true;\n}\n","import { SocketService } from '../../../SocketService';\nimport { EventType } from '../../../types/EventType';\n\n/**\n * Returns an asynchronous handler function to handle the 'clients_connected' event for a specific channel.\n * This handler informs the other layer about clients reconnection, emits a CLIENTS_CONNECTED event,\n * and handles key exchange scenarios and reconnection situations.\n *\n * @param instance The current instance of the SocketService.\n * @param channelId The ID of the channel associated with the handler.\n * @returns {Function} An asynchronous handler function for the 'clients_connected' event.\n */\nexport function handleClientsConnected(\n  instance: SocketService,\n  channelId: string,\n) {\n  return async (_id: string) => {\n    if (instance.state.debug) {\n      console.debug(\n        `SocketService::${\n          instance.state.context\n        }::setupChannelListener::on 'clients_connected-${channelId}'  resumed=${\n          instance.state.resumed\n        }  clientsPaused=${\n          instance.state.clientsPaused\n        } keysExchanged=${instance.state.keyExchange?.areKeysExchanged()} isOriginator=${\n          instance.state.isOriginator\n        }`,\n      );\n    }\n\n    // Inform other layer of clients reconnection\n    instance.emit(EventType.CLIENTS_CONNECTED, {\n      isOriginator: instance.state.isOriginator,\n      keysExchanged: instance.state.keyExchange?.areKeysExchanged(),\n      context: instance.state.context,\n    });\n\n    if (instance.state.resumed) {\n      if (!instance.state.isOriginator) {\n        // should ask to redo a key exchange because it wasn't paused.\n        if (instance.state.debug) {\n          console.debug(\n            `SocketService::${\n              instance.state.context\n            }::on 'clients_connected' / keysExchanged=${instance.state.keyExchange?.areKeysExchanged()} -- backward compatibility`,\n          );\n        }\n\n        instance.state.keyExchange?.start({\n          isOriginator: instance.state.isOriginator ?? false,\n        });\n      }\n      // resumed switched when connection resume.\n      instance.state.resumed = false;\n    } else if (instance.state.clientsPaused) {\n      console.debug(\n        `SocketService::on 'clients_connected' skip sending originatorInfo on pause`,\n      );\n    } else if (!instance.state.isOriginator) {\n      // Reconnect scenario --- maybe web dapp got refreshed\n      if (instance.state.debug) {\n        console.debug(\n          `SocketService::${\n            instance.state.context\n          }::on 'clients_connected' / keysExchanged=${instance.state.keyExchange?.areKeysExchanged()} -- backward compatibility`,\n        );\n      }\n\n      // Add delay in case exchange was already initiated by dapp.\n      // Always request key exchange from wallet since it looks like a reconnection.\n      instance.state.keyExchange?.start({\n        isOriginator: instance.state.isOriginator ?? false,\n        force: true,\n      });\n    }\n\n    instance.state.clientsConnected = true;\n    instance.state.clientsPaused = false;\n  };\n}\n","import { SocketService } from '../../../SocketService';\nimport { EventType } from '../../../types/EventType';\n\n/**\n * Returns a handler function to handle the 'channel_created' event for a specific channel.\n * This handler emits a CHANNEL_CREATED event using the provided SocketService instance and ID.\n *\n * @param instance The current instance of the SocketService.\n * @param channelId The ID of the channel associated with the handler.\n * @returns {Function} A handler function for the 'channel_created' event.\n */\nexport function handleChannelCreated(\n  instance: SocketService,\n  channelId: string,\n) {\n  return (id: string) => {\n    if (instance.state.debug) {\n      console.debug(\n        `SocketService::${instance.state.context}::setupChannelListener::on 'channel_created-${channelId}'`,\n        id,\n      );\n    }\n    instance.emit(EventType.CHANNEL_CREATED, id);\n  };\n}\n","import { SocketService } from '../../../SocketService';\nimport { EventType } from '../../../types/EventType';\n\n/**\n * Returns a handler function to handle the 'clients_disconnected' event.\n * This handler updates the clientsConnected state to false, and if the instance is the originator\n * and clients are not paused, it cleans the key exchange.\n * It also emits the CLIENTS_DISCONNECTED event.\n *\n * @param instance The current instance of the SocketService.\n * @param channelId The ID of the channel.\n * @returns {Function} A handler function for the 'clients_disconnected' event.\n */\nexport function handlesClientsDisconnected(\n  instance: SocketService,\n  channelId: string,\n) {\n  return () => {\n    instance.state.clientsConnected = false;\n    if (instance.state.debug) {\n      console.debug(\n        `SocketService::${instance.state.context}::setupChannelListener::on 'clients_disconnected-${channelId}'`,\n      );\n    }\n\n    if (instance.state.isOriginator && !instance.state.clientsPaused) {\n      // If it wasn't paused - need to reset keys.\n      instance.state.keyExchange?.clean();\n    }\n\n    instance.emit(EventType.CLIENTS_DISCONNECTED, channelId);\n  };\n}\n","import { SocketService } from '../../../SocketService';\nimport { EventType } from '../../../types/EventType';\nimport { InternalEventType } from '../../../types/InternalEventType';\nimport { KeyExchangeMessageType } from '../../../types/KeyExchangeMessageType';\nimport { MessageType } from '../../../types/MessageType';\nimport { checkSameId } from '../ChannelManager';\n\n/**\n * Returns a handler function to handle incoming messages.\n * This handler processes the incoming message based on its type and key exchange status.\n *\n * @param instance The current instance of the SocketService.\n * @param channelId The ID of the channel the message belongs to.\n * @returns {Function} A handler function for incoming messages.\n */\nexport function handleMessage(instance: SocketService, channelId: string) {\n  return ({\n    id,\n    message,\n    error,\n  }: {\n    id: string;\n    message: any;\n    error?: any;\n  }) => {\n    if (instance.state.debug) {\n      console.debug(\n        `SocketService::${\n          instance.state.context\n        }::on 'message' ${channelId} keysExchanged=${instance.state.keyExchange?.areKeysExchanged()}`,\n        message,\n      );\n    }\n\n    if (error) {\n      if (instance.state.debug) {\n        console.debug(`\n      SocketService::${instance.state.context}::on 'message' error=${error}`);\n      }\n\n      throw new Error(error);\n    }\n\n    try {\n      checkSameId(instance.state, id);\n    } catch (err) {\n      console.error(`ignore message --- wrong id `, message);\n      return;\n    }\n\n    if (\n      instance.state.isOriginator &&\n      message?.type === KeyExchangeMessageType.KEY_HANDSHAKE_START\n    ) {\n      if (instance.state.debug) {\n        console.debug(\n          `SocketService::${instance.state.context}::on 'message' received HANDSHAKE_START isOriginator=${instance.state.isOriginator}`,\n          message,\n        );\n      }\n\n      instance.state.keyExchange?.start({\n        isOriginator: instance.state.isOriginator ?? false,\n        force: true,\n      });\n      return;\n    }\n\n    // TODO can be removed once session persistence fully vetted.\n    if (message?.type === MessageType.PING) {\n      if (instance.state.debug) {\n        console.debug(\n          `SocketService::${instance.state.context}::on 'message' ping `,\n        );\n      }\n\n      instance.emit(EventType.MESSAGE, { message: { type: 'ping' } });\n      return;\n    }\n\n    if (instance.state.debug) {\n      // Special case to manage resetting key exchange when keys are already exchanged\n      console.debug(\n        `SocketService::${instance.state.context}::on 'message' originator=${\n          instance.state.isOriginator\n        }, type=${\n          message?.type\n        }, keysExchanged=${instance.state.keyExchange?.areKeysExchanged()}`,\n      );\n    }\n\n    if (message?.type?.startsWith('key_handshake')) {\n      if (instance.state.debug) {\n        console.debug(\n          `SocketService::${instance.state.context}::on 'message' emit KEY_EXCHANGE`,\n          message,\n        );\n      }\n\n      instance.emit(InternalEventType.KEY_EXCHANGE, {\n        message,\n        context: instance.state.context,\n      });\n      return;\n    }\n\n    if (!instance.state.keyExchange?.areKeysExchanged()) {\n      // Sometime the keys exchanged status is not updated correctly\n      // check if we can decrypt the message without errors and if so update the status and continue.\n      let canDecrypt = false;\n      try {\n        instance.state.keyExchange?.decryptMessage(message);\n        canDecrypt = true;\n      } catch (err) {\n        // Ignore error.\n      }\n\n      if (canDecrypt) {\n        console.warn(`Invalid key exchange status detected --- updating it.`);\n        instance.state.keyExchange?.setKeysExchanged(true);\n      } else {\n        // received encrypted message before keys were exchanged.\n        if (instance.state.isOriginator) {\n          instance.state.keyExchange?.start({\n            isOriginator: instance.state.isOriginator ?? false,\n          });\n        } else {\n          // Request new key exchange\n          instance.sendMessage({\n            type: KeyExchangeMessageType.KEY_HANDSHAKE_START,\n          });\n        }\n\n        //  ignore message and wait for completion.\n        console.warn(\n          `Message ignored because invalid key exchange status. step=${\n            instance.state.keyExchange?.getKeyInfo().step\n          }`,\n          instance.state.keyExchange?.getKeyInfo(),\n          message,\n        );\n        return;\n      }\n    } else if (message.toString().indexOf('type') !== -1) {\n      // Even if keys were exchanged, if the message is not encrypted, emit it.\n      // *** instance is not supposed to happen ***\n      console.warn(\n        `SocketService::on 'message' received non encrypted unkwown message`,\n      );\n      instance.emit(EventType.MESSAGE, message);\n      return;\n    }\n\n    const decryptedMessage =\n      instance.state.keyExchange?.decryptMessage(message);\n    const messageReceived = JSON.parse(decryptedMessage ?? '{}');\n\n    if (messageReceived?.type === MessageType.PAUSE) {\n      /**\n       * CommunicationLayer shouldn't be aware of the protocol details but we make an exception to manager session persistence.\n       * Receiving pause is the correct way to quit MetaMask app,\n       * but in case it is killed we won't receive a PAUSE signal and thus need to re-create the handshake.\n       */\n      instance.state.clientsPaused = true;\n    } else {\n      instance.state.clientsPaused = false;\n    }\n\n    if (instance.state.isOriginator && messageReceived.data) {\n      // inform cache from result\n      const rpcMessage = messageReceived.data as {\n        id: string;\n        result: unknown;\n        error: {\n          code: number;\n          message: string;\n          stack: string;\n        };\n      };\n      const initialRPCMethod = instance.state.rpcMethodTracker[rpcMessage.id];\n      if (initialRPCMethod) {\n        const elapsedTime = Date.now() - initialRPCMethod.timestamp;\n        if (instance.state.debug) {\n          console.debug(\n            `SocketService::${instance.state.context}::on 'message' received answer for id=${rpcMessage.id} method=${initialRPCMethod.method} responseTime=${elapsedTime}`,\n            messageReceived,\n          );\n        }\n        const rpcResult = {\n          ...initialRPCMethod,\n          result: rpcMessage.result,\n          error: rpcMessage.error\n            ? {\n                code: rpcMessage.error?.code,\n                message: rpcMessage.error?.message,\n              }\n            : undefined,\n          elapsedTime,\n        };\n        instance.state.rpcMethodTracker[rpcMessage.id] = rpcResult;\n        instance.emit(EventType.RPC_UPDATE);\n\n        if (instance.state.debug) {\n          console.debug(\n            `HACK (wallet <7.3) update rpcMethodTracker`,\n            rpcResult,\n          );\n        }\n        // FIXME hack while waiting for mobile release 7.3\n        instance.emit(EventType.AUTHORIZED);\n      }\n    }\n\n    instance.emit(EventType.MESSAGE, { message: messageReceived });\n  };\n}\n","import { SocketServiceState } from '../../../SocketService';\n\n/**\n * Validates if the provided ID matches the current channel ID of the SocketServiceState. If the IDs do not match and debugging is enabled, an error message is logged to the console. An error is thrown for a mismatched ID.\n *\n * @param state The current state of the SocketService instance.\n * @param id The ID to be checked against the current channel ID.\n * @throws {Error} Throws an error if the provided ID does not match the current channel ID.\n */\nexport function checkSameId(state: SocketServiceState, id: string) {\n  if (id !== state.channelId) {\n    if (state.debug) {\n      console.error(`Wrong id ${id} - should be ${state.channelId}`);\n    }\n    throw new Error('Wrong id');\n  }\n}\n","import { SocketService } from '../../../SocketService';\nimport { EventType } from '../../../types/EventType';\n\n/**\n * Returns a handler function to handle the 'clients_waiting_to_join' event for a specific channel.\n * This handler emits a CLIENTS_WAITING event with the number of waiting users.\n *\n * @param instance The current instance of the SocketService.\n * @param channelId The ID of the channel associated with the handler.\n * @returns {Function} A handler function for the 'clients_waiting_to_join' event.\n */\nexport function handleClientsWaitingToJoin(\n  instance: SocketService,\n  channelId: string,\n) {\n  return (numberUsers: number) => {\n    if (instance.state.debug) {\n      console.debug(\n        `SocketService::${instance.state.context}::setupChannelListener::on 'clients_waiting_to_join-${channelId}'`,\n        numberUsers,\n      );\n    }\n    instance.emit(EventType.CLIENTS_WAITING, numberUsers);\n  };\n}\n","import { SocketService } from '../../../SocketService';\nimport { EventType } from '../../../types/EventType';\n\n/**\n * Returns a handler function to handle the 'KEY_INFO' event.\n * This handler emits the KEY_INFO event with the provided event data.\n *\n * @param instance The current instance of the SocketService.\n * @param {any} event The event data for the 'KEY_INFO' event.\n * @returns {Function} A handler function for the 'KEY_INFO' event.\n */\nexport function handleKeyInfo(instance: SocketService) {\n  return (event: any) => {\n    if (instance.state.debug) {\n      console.debug(`SocketService::on 'KEY_INFO'`, event);\n    }\n    instance.emit(EventType.KEY_INFO, event);\n  };\n}\n","import { SocketService } from '../../../SocketService';\nimport { EventType } from '../../../types/EventType';\nimport { ServiceStatus } from '../../../types/ServiceStatus';\n\n/**\n * Returns a handler function to handle the 'keys_exchanged' event.\n * This handler emits the KEYS_EXCHANGED event with the current key exchange status and whether the instance is the originator.\n * Additionally, it emits the SERVICE_STATUS event with the current key information.\n *\n * @param instance The current instance of the SocketService.\n * @returns {Function} A handler function for the 'keys_exchanged' event.\n */\nexport function handleKeysExchanged(instance: SocketService) {\n  return () => {\n    if (instance.state.debug) {\n      console.debug(\n        `SocketService::on 'keys_exchanged' keyschanged=${instance.state.keyExchange?.areKeysExchanged()}`,\n      );\n    }\n\n    // Propagate key exchange event\n    instance.emit(EventType.KEYS_EXCHANGED, {\n      keysExchanged: instance.state.keyExchange?.areKeysExchanged(),\n      isOriginator: instance.state.isOriginator,\n    });\n    const serviceStatus: ServiceStatus = {\n      keyInfo: instance.getKeyInfo(),\n    };\n    instance.emit(EventType.SERVICE_STATUS, serviceStatus);\n  };\n}\n","import { SocketService } from '../../../SocketService';\nimport { CommunicationLayerMessage } from '../../../types/CommunicationLayerMessage';\nimport { handleKeyHandshake, validateKeyExchange } from '../KeysManager';\nimport { encryptAndSendMessage } from './encryptAndSendMessage';\nimport { handleRpcReplies } from './handleRpcReplies';\nimport { trackRpcMethod } from './trackRpcMethod';\n\n/**\n * Handles sending a message using the SocketService instance.\n * It first checks if a channel has been created and throws an error if not.\n * Then, it logs debug information about the message and its encryption status.\n * It checks if the message is a key handshake message and handles it if it is.\n * If the message is not a key handshake message, it validates the key exchange status.\n * It tracks the RPC method if applicable.\n * It encrypts and sends the message.\n * Finally, if the user is the originator, it waits for a reply in case of certain messages.\n *\n * @param instance The current instance of the SocketService.\n * @param message The message to be sent.\n */\nexport function handleSendMessage(\n  instance: SocketService,\n  message: CommunicationLayerMessage,\n) {\n  if (!instance.state.channelId) {\n    throw new Error('Create a channel first');\n  }\n\n  if (instance.state.debug) {\n    console.debug(\n      `SocketService::${\n        instance.state.context\n      }::sendMessage() areKeysExchanged=${instance.state.keyExchange?.areKeysExchanged()}`,\n      message,\n    );\n  }\n\n  const isKeyHandshakeMessage = message?.type?.startsWith('key_handshake');\n\n  if (isKeyHandshakeMessage) {\n    handleKeyHandshake(instance, message);\n    return;\n  }\n\n  validateKeyExchange(instance, message);\n\n  // TODO Prevent sending same method multiple time which can sometime happen during initialization\n  trackRpcMethod(instance, message);\n\n  encryptAndSendMessage(instance, message);\n\n  // Only makes sense on originator side.\n  // wait for reply when eth_requestAccounts is sent.\n  handleRpcReplies(instance, message).catch((err) => {\n    console.warn('Error handleRpcReplies', err);\n  });\n}\n","import { SocketService } from '../../../SocketService';\nimport { CommunicationLayerMessage } from '../../../types/CommunicationLayerMessage';\nimport { EventType } from '../../../types/EventType';\n\n/**\n * Handles the sending of key handshake messages.\n * If the message type starts with 'key_handshake', the function sends the message without encryption.\n *\n * @param instance The current instance of the SocketService.\n * @param message The message to be sent.\n * @returns {boolean} Returns true if the message was a key handshake message, otherwise false.\n */\nexport function handleKeyHandshake(\n  instance: SocketService,\n  message: CommunicationLayerMessage,\n) {\n  if (instance.state.debug) {\n    console.debug(\n      `SocketService::${instance.state.context}::sendMessage()`,\n      message,\n    );\n  }\n\n  instance.state.socket?.emit(EventType.MESSAGE, {\n    id: instance.state.channelId,\n    context: instance.state.context,\n    message,\n  });\n}\n","import { SocketService } from '../../../SocketService';\nimport { CommunicationLayerMessage } from '../../../types/CommunicationLayerMessage';\n\n/**\n * Validates whether key exchange has been completed before sending a message.\n * If keys are not exchanged, an error is thrown.\n *\n * @param instance The current instance of the SocketService.\n * @param message The message for which to validate key exchange.\n * @throws {Error} Thrown if keys have not been exchanged.\n */\nexport function validateKeyExchange(\n  instance: SocketService,\n  message: CommunicationLayerMessage,\n) {\n  if (!instance.state.keyExchange?.areKeysExchanged()) {\n    if (instance.state.debug) {\n      console.debug(\n        `SocketService::${instance.state.context}::sendMessage() ERROR keys not exchanged`,\n        message,\n      );\n    }\n    throw new Error('Keys not exchanged BBB');\n  }\n}\n","import { SocketService } from '../../../SocketService';\nimport { CommunicationLayerMessage } from '../../../types/CommunicationLayerMessage';\nimport { EventType } from '../../../types/EventType';\n\n/**\n * Tracks the RPC method for the provided message in the `rpcMethodTracker` object.\n * If the instance is the originator of the message and the message has an associated RPC ID,\n * it records the method and timestamp in the `rpcMethodTracker` for later reference.\n *\n * @param instance The current instance of the SocketService.\n * @param message The message for which to track the RPC method.\n */\nexport function trackRpcMethod(\n  instance: SocketService,\n  message: CommunicationLayerMessage,\n) {\n  const method = message?.method ?? '';\n  const rpcId = message?.id;\n  if (instance.state.isOriginator && rpcId) {\n    instance.state.rpcMethodTracker[rpcId] = {\n      timestamp: Date.now(),\n      method,\n    };\n    instance.emit(EventType.RPC_UPDATE);\n  }\n}\n","import { SocketService } from '../../../SocketService';\nimport { CommunicationLayerMessage } from '../../../types/CommunicationLayerMessage';\nimport { EventType } from '../../../types/EventType';\nimport { MessageType } from '../../../types/MessageType';\n\n/**\n * Encrypts and sends the provided message using the SocketService instance.\n * It encrypts the message using the key exchange and prepares the message to be sent.\n * If the instance has plaintext debugging enabled, it includes the plaintext version of the message.\n * The function logs debug information about the encrypted message before sending it.\n *\n * @param instance The current instance of the SocketService.\n * @param message The message to be encrypted and sent.\n */\nexport function encryptAndSendMessage(\n  instance: SocketService,\n  message: CommunicationLayerMessage,\n) {\n  const encryptedMessage = instance.state.keyExchange?.encryptMessage(\n    JSON.stringify(message),\n  );\n  const messageToSend = {\n    id: instance.state.channelId,\n    context: instance.state.context,\n    message: encryptedMessage,\n    plaintext: instance.state.hasPlaintext\n      ? JSON.stringify(message)\n      : undefined,\n  };\n  if (instance.state.debug) {\n    console.debug(\n      `SocketService::${instance.state.context}::sendMessage()`,\n      messageToSend,\n    );\n  }\n\n  if (message.type === MessageType.TERMINATE) {\n    instance.state.manualDisconnect = true;\n  }\n  instance.state.socket?.emit(EventType.MESSAGE, messageToSend);\n}\n","import { SocketService } from '../../../SocketService';\nimport { CommunicationLayerMessage } from '../../../types/CommunicationLayerMessage';\nimport { waitForRpc } from '../../../utils/wait';\n\n/**\n * Handles the waiting for RPC replies for the provided message.\n * If the instance is the originator of the message and the message has an associated RPC ID,\n * it waits for the corresponding RPC reply using the `waitForRpc` utility function.\n * When the reply is received, it logs debug information about the RPC reply.\n *\n * @param instance The current instance of the SocketService.\n * @param message The message for which to handle RPC replies.\n */\nexport async function handleRpcReplies(\n  instance: SocketService,\n  message: CommunicationLayerMessage,\n) {\n  const rpcId = message?.id;\n  const method = message?.method ?? '';\n\n  if (instance.state.isOriginator && rpcId) {\n    try {\n      const result = await waitForRpc(\n        rpcId,\n        instance.state.rpcMethodTracker,\n        200,\n      );\n      if (instance.state.debug) {\n        console.debug(\n          `SocketService::waitForRpc id=${message.id} ${method} ( ${result.elapsedTime} ms)`,\n          result.result,\n        );\n      }\n    } catch (err) {\n      console.warn(`Error rpcId=${message.id} ${method}`, err);\n    }\n  }\n}\n","import { EventEmitter2 } from 'eventemitter2';\nimport { io, Socket } from 'socket.io-client';\nimport { DEFAULT_SERVER_URL, DEFAULT_SOCKET_TRANSPORTS } from './config';\nimport { ECIESProps } from './ECIES';\nimport { KeyExchange } from './KeyExchange';\nimport { createChannel } from './services/SocketService/ChannelManager';\nimport {\n  connectToChannel,\n  disconnect,\n  pause,\n  ping,\n  resume,\n} from './services/SocketService/ConnectionManager';\nimport { keyCheck, resetKeys } from './services/SocketService/KeysManager';\nimport { handleSendMessage } from './services/SocketService/MessageHandlers';\nimport { Channel } from './types/Channel';\nimport { CommunicationLayer } from './types/CommunicationLayer';\nimport { CommunicationLayerMessage } from './types/CommunicationLayerMessage';\nimport { CommunicationLayerPreference } from './types/CommunicationLayerPreference';\nimport { ConnectToChannelOptions } from './types/ConnectToChannelOptions';\nimport { DisconnectOptions } from './types/DisconnectOptions';\nimport { KeyInfo } from './types/KeyInfo';\nimport { CommunicationLayerLoggingOptions } from './types/LoggingOptions';\n\nexport interface SocketServiceProps {\n  communicationLayerPreference: CommunicationLayerPreference;\n  reconnect?: boolean;\n  transports?: string[];\n  otherPublicKey?: string;\n  communicationServerUrl: string;\n  context: string;\n  ecies?: ECIESProps;\n  logging?: CommunicationLayerLoggingOptions;\n}\n\nexport interface SocketServiceState {\n  clientsConnected: boolean;\n  clientsPaused: boolean;\n  isOriginator?: boolean;\n  channelId?: string;\n  manualDisconnect: boolean;\n  resumed?: boolean;\n  communicationLayerPreference?: CommunicationLayerPreference;\n  context?: string;\n  withKeyExchange?: boolean;\n  communicationServerUrl: string;\n  debug?: boolean;\n  rpcMethodTracker: RPCMethodCache;\n  hasPlaintext: boolean;\n  socket?: Socket;\n  setupChannelListeners?: boolean;\n  keyExchange?: KeyExchange;\n}\n\nexport interface RPCMethodResult {\n  timestamp: number; // timestamp of last request\n  method: string;\n  result?: unknown;\n  error?: unknown;\n  elapsedTime?: number; // elapsed time between request and response\n}\nexport interface RPCMethodCache {\n  [id: string]: RPCMethodResult;\n}\n\nexport type SocketServiceInstanceType = SocketService &\n  EventEmitter2 &\n  CommunicationLayer;\n\nexport class SocketService extends EventEmitter2 implements CommunicationLayer {\n  public state: SocketServiceState = {\n    clientsConnected: false,\n    /**\n     * Special flag used to session persistence in case MetaMask disconnects without Pause,\n     * it means we need to re-create a new key handshake.\n     */\n    clientsPaused: false,\n    manualDisconnect: false,\n    rpcMethodTracker: {},\n    hasPlaintext: false,\n    communicationServerUrl: '',\n  };\n\n  constructor({\n    otherPublicKey,\n    reconnect,\n    communicationLayerPreference,\n    transports,\n    communicationServerUrl,\n    context,\n    ecies,\n    logging,\n  }: SocketServiceProps) {\n    super();\n\n    this.state.resumed = reconnect;\n    this.state.context = context;\n    this.state.communicationLayerPreference = communicationLayerPreference;\n    this.state.debug = logging?.serviceLayer === true;\n    this.state.communicationServerUrl = communicationServerUrl;\n    this.state.hasPlaintext =\n      this.state.communicationServerUrl !== DEFAULT_SERVER_URL &&\n      logging?.plaintext === true;\n\n    const options = {\n      autoConnect: false,\n      transports: DEFAULT_SOCKET_TRANSPORTS,\n    };\n\n    if (transports) {\n      options.transports = transports;\n    }\n\n    if (this.state.debug) {\n      console.debug(\n        `SocketService::constructor() Socket IO url: ${this.state.communicationServerUrl}`,\n      );\n    }\n\n    this.state.socket = io(communicationServerUrl, options);\n\n    const keyExchangeInitParameter = {\n      communicationLayer: this,\n      otherPublicKey,\n      sendPublicKey: false,\n      context: this.state.context,\n      ecies,\n      logging,\n    };\n\n    this.state.keyExchange = new KeyExchange(keyExchangeInitParameter);\n  }\n\n  resetKeys(): void {\n    return resetKeys(this);\n  }\n\n  createChannel(): Channel {\n    return createChannel(this);\n  }\n\n  connectToChannel({\n    channelId,\n    isOriginator = false,\n    withKeyExchange = false,\n  }: ConnectToChannelOptions): void {\n    return connectToChannel({\n      options: {\n        channelId,\n        isOriginator,\n        withKeyExchange,\n      },\n      instance: this,\n    });\n  }\n\n  getKeyInfo(): KeyInfo {\n    return (this.state.keyExchange as KeyExchange).getKeyInfo();\n  }\n\n  keyCheck() {\n    return keyCheck(this);\n  }\n\n  getKeyExchange() {\n    return this.state.keyExchange as KeyExchange;\n  }\n\n  sendMessage(message: CommunicationLayerMessage): void {\n    return handleSendMessage(this, message);\n  }\n\n  ping() {\n    return ping(this);\n  }\n\n  pause(): void {\n    return pause(this);\n  }\n\n  isConnected() {\n    return this.state.socket?.connected as boolean;\n  }\n\n  resume(): void {\n    return resume(this);\n  }\n\n  getRPCMethodTracker() {\n    return this.state.rpcMethodTracker;\n  }\n\n  disconnect(options?: DisconnectOptions): void {\n    return disconnect(this, options);\n  }\n}\n","import { SocketService } from '../../../SocketService';\n\n/**\n * Resets the keys associated with a SocketService instance.\n * If debugging is enabled, a debug message is logged.\n *\n * @param instance The current instance of the SocketService.\n */\nexport function resetKeys(instance: SocketService) {\n  if (instance.state.debug) {\n    console.debug(`SocketService::resetKeys()`);\n  }\n  instance.state.keyExchange?.resetKeys();\n}\n","import { v4 as uuidv4 } from 'uuid';\nimport { SocketService } from '../../../SocketService';\nimport { EventType } from '../../../types/EventType';\nimport { setupChannelListeners } from './setupChannelListeners';\n\n/**\n * Creates a new communication channel for a given SocketService instance.\n * If debugging is enabled, logs the creation process. If the socket is not\n * connected, it initiates a connection. The function also sets up listeners\n * for the new channel and emits a JOIN_CHANNEL event.\n *\n * @param instance The current instance of the SocketService.\n * @returns {Object} An object containing the newly generated channel ID and\n * the public key associated with the instance, if available.\n * @property {string} channelId The unique identifier for the newly created channel.\n * @property {string} pubKey The public key associated with the SocketService\n * instance, or an empty string if not available.\n */\nexport function createChannel(instance: SocketService) {\n  if (instance.state.debug) {\n    console.debug(`SocketService::${instance.state.context}::createChannel()`);\n  }\n\n  if (!instance.state.socket?.connected) {\n    instance.state.socket?.connect();\n  }\n\n  instance.state.manualDisconnect = false;\n  instance.state.isOriginator = true;\n  const channelId = uuidv4();\n  instance.state.channelId = channelId;\n  setupChannelListeners(instance, channelId);\n  instance.state.socket?.emit(\n    EventType.JOIN_CHANNEL,\n    channelId,\n    `${instance.state.context}createChannel`,\n  );\n  return {\n    channelId,\n    pubKey: instance.state.keyExchange?.getMyPublicKey() || '',\n  };\n}\n","import { SocketService } from '../../../SocketService';\nimport { ConnectToChannelOptions } from '../../../types/ConnectToChannelOptions';\nimport { EventType } from '../../../types/EventType';\nimport { setupChannelListeners } from '../ChannelManager';\n\n/**\n * Connects a SocketService instance to a specified channel.\n * If the socket is already connected, an error is thrown.\n * The function sets up listeners for the channel and emits a JOIN_CHANNEL event.\n *\n * @param options The options required to connect to the channel,\n * including the channel ID, whether a key exchange is needed,\n * and if the current instance is the originator.\n * @param instance The current instance of the SocketService.\n * @throws {Error} Throws an error if the socket is already connected.\n */\nexport function connectToChannel({\n  options,\n  instance,\n}: {\n  options: ConnectToChannelOptions;\n  instance: SocketService;\n}) {\n  const { channelId, withKeyExchange, isOriginator } = options;\n\n  if (instance.state.debug) {\n    console.debug(\n      `SocketService::${instance.state.context}::connectToChannel() channelId=${channelId} isOriginator=${isOriginator}`,\n      instance.state.keyExchange?.toString(),\n    );\n  }\n\n  if (instance.state.socket?.connected) {\n    throw new Error(`socket already connected`);\n  }\n\n  instance.state.manualDisconnect = false;\n  instance.state.socket?.connect();\n  instance.state.withKeyExchange = withKeyExchange;\n  instance.state.isOriginator = isOriginator;\n  instance.state.channelId = channelId;\n  setupChannelListeners(instance, channelId);\n  instance.state.socket?.emit(\n    EventType.JOIN_CHANNEL,\n    channelId,\n    `${instance.state.context}_connectToChannel`,\n  );\n}\n","import { SocketService } from '../../../SocketService';\nimport { EventType } from '../../../types/EventType';\nimport { KeyExchangeMessageType } from '../../../types/KeyExchangeMessageType';\n\n/**\n * Checks the validity of the keys associated with a SocketService instance.\n * A KEY_HANDSHAKE_CHECK message is emitted to the socket, containing\n * the instance's channel ID and public key. This message can be used to verify\n * the validity of the keys on the other side of the communication.\n *\n * @param instance The current instance of the SocketService.\n */\nexport function keyCheck(instance: SocketService) {\n  instance.state.socket?.emit(EventType.MESSAGE, {\n    id: instance.state.channelId,\n    context: instance.state.context,\n    message: {\n      type: KeyExchangeMessageType.KEY_HANDSHAKE_CHECK,\n      pubkey: instance.getKeyInfo().ecies.otherPubKey,\n    },\n  });\n}\n","import { SocketService } from '../../../SocketService';\nimport { EventType } from '../../../types/EventType';\nimport { MessageType } from '../../../types/MessageType';\n\n/**\n * Sends a PING message using a SocketService instance.\n * If the instance is not the originator and keys have been exchanged,\n * a READY message is sent. If the keys haven't been exchanged,\n * the key exchange process is initiated. Finally, a PING message\n * is emitted to the socket.\n *\n * @param instance The current instance of the SocketService.\n */\nexport function ping(instance: SocketService) {\n  if (instance.state.debug) {\n    console.debug(\n      `SocketService::${instance.state.context}::ping() originator=${\n        instance.state.isOriginator\n      } keysExchanged=${instance.state.keyExchange?.areKeysExchanged()}`,\n    );\n  }\n\n  if (instance.state.isOriginator) {\n    if (instance.state.keyExchange?.areKeysExchanged()) {\n      console.warn(\n        `SocketService::${instance.state.context}::ping() sending READY message`,\n      );\n      instance.sendMessage({ type: MessageType.READY });\n    } else {\n      console.warn(\n        `SocketService::${instance.state.context}::ping() starting key exchange`,\n      );\n\n      instance.state.keyExchange?.start({\n        isOriginator: instance.state.isOriginator ?? false,\n      });\n    }\n  }\n\n  instance.state.socket?.emit(EventType.MESSAGE, {\n    id: instance.state.channelId,\n    context: instance.state.context,\n    message: {\n      type: MessageType.PING,\n    },\n  });\n}\n","import { SocketService } from '../../../SocketService';\nimport { MessageType } from '../../../types/MessageType';\n\n/**\n * Pauses the connection of a SocketService instance.\n * If the keys have been exchanged, a PAUSE message is sent before\n * the socket is manually disconnected.\n *\n * @param instance The current instance of the SocketService.\n */\nexport function pause(instance: SocketService) {\n  if (instance.state.debug) {\n    console.debug(`SocketService::${instance.state.context}::pause()`);\n  }\n  instance.state.manualDisconnect = true;\n  if (instance.state.keyExchange?.areKeysExchanged()) {\n    instance.sendMessage({ type: MessageType.PAUSE });\n  }\n  instance.state.socket?.disconnect();\n}\n","import { SocketService } from '../../../SocketService';\nimport { EventType } from '../../../types/EventType';\nimport { MessageType } from '../../../types/MessageType';\n\n/**\n * Resumes the connection of a SocketService instance.\n * If the socket is already connected, a debug message is logged.\n * Otherwise, the socket is connected and a JOIN_CHANNEL event is emitted.\n * The function also ensures that the necessary key exchanges are\n * performed before resuming the connection. If keys have been exchanged\n * and the instance is not the originator, a READY message is sent.\n *\n * @param instance The current instance of the SocketService.\n */\nexport function resume(instance: SocketService) {\n  if (instance.state.debug) {\n    console.debug(\n      `SocketService::${instance.state.context}::resume() connected=${\n        instance.state.socket?.connected\n      } manualDisconnect=${instance.state.manualDisconnect} resumed=${\n        instance.state.resumed\n      } keysExchanged=${instance.state.keyExchange?.areKeysExchanged()}`,\n    );\n  }\n\n  if (instance.state.socket?.connected) {\n    if (instance.state.debug) {\n      console.debug(`SocketService::resume() already connected.`);\n    }\n  } else {\n    instance.state.socket?.connect();\n    if (instance.state.debug) {\n      console.debug(\n        `SocketService::resume() after connecting socket --> connected=${instance.state.socket?.connected}`,\n      );\n    }\n\n    // Useful to re-emmit otherwise dapp might sometime loose track of the connection event.\n    instance.state.socket?.emit(\n      EventType.JOIN_CHANNEL,\n      instance.state.channelId,\n      `${instance.state.context}_resume`,\n    );\n  }\n\n  // Always try to recover key exchange from both side (wallet / dapp)\n  if (instance.state.keyExchange?.areKeysExchanged()) {\n    if (!instance.state.isOriginator) {\n      // this message will be ignored by the dapp if it has restarted and updated keys.\n      // Dapp will then init another key exchange.\n      instance.sendMessage({ type: MessageType.READY });\n    }\n  } else if (!instance.state.isOriginator) {\n    // Ask to start key exchange\n    instance.state.keyExchange?.start({\n      isOriginator: instance.state.isOriginator ?? false,\n    });\n  }\n\n  instance.state.manualDisconnect = false;\n  instance.state.resumed = true;\n}\n","import { SocketService } from '../../../SocketService';\nimport { DisconnectOptions } from '../../../types/DisconnectOptions';\n\n/**\n * Disconnects a SocketService instance from its current connection.\n * If the termination option is provided, the channel ID is reset and\n * any existing key exchanges are cleaned up. Additionally, the rpcMethodTracker\n * is reset and the socket is manually disconnected.\n *\n * @param instance The current instance of the SocketService.\n * @param options Optional parameters for the disconnect process,\n * including whether to terminate the connection and the channel ID.\n */\nexport function disconnect(\n  instance: SocketService,\n  options?: DisconnectOptions,\n) {\n  if (instance.state.debug) {\n    console.debug(\n      `SocketService::${instance.state.context}::disconnect()`,\n      options,\n    );\n  }\n\n  if (options?.terminate) {\n    instance.state.channelId = options.channelId;\n    instance.state.keyExchange?.clean();\n  }\n  // Reset rpcMethodTracker\n  instance.state.rpcMethodTracker = {};\n  instance.state.manualDisconnect = true;\n  instance.state.socket?.disconnect();\n}\n","export enum CommunicationLayerPreference {\n  SOCKET = 'socket',\n}\n","export enum PlatformType {\n  // React Native or Nodejs\n  NonBrowser = 'nodejs',\n  // MetaMask Mobile in-app browser\n  MetaMaskMobileWebview = 'in-app-browser',\n  // Desktop Browser\n  DesktopWeb = 'web-desktop',\n  // Mobile Browser\n  MobileWeb = 'web-mobile',\n  // ReactNative\n  ReactNative = 'react-native',\n}\n","export enum TrackingEvents {\n  REQUEST = 'sdk_connect_request_started',\n  REQUEST_MOBILE = 'sdk_connect_request_started_mobile',\n  RECONNECT = 'sdk_reconnect_request_started',\n  CONNECTED = 'sdk_connection_established',\n  CONNECTED_MOBILE = 'sdk_connection_established_mobile',\n  AUTHORIZED = 'sdk_connection_authorized',\n  REJECTED = 'sdk_connection_rejected',\n  TERMINATED = 'sdk_connection_terminated',\n  DISCONNECTED = 'sdk_disconnected',\n  SDK_USE_EXTENSION = 'sdk_use_extension',\n  SDK_EXTENSION_UTILIZED = 'sdk_extension_utilized',\n  SDK_USE_INAPP_BROWSER = 'sdk_use_inapp_browser',\n}\n","export enum AutoConnectType {\n  RENEW = 'renew',\n  LINK = 'link',\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { EventType } from '../../../types/EventType';\nimport { PlatformType } from '../../../types/PlatformType';\nimport { wait } from '../../../utils/wait';\n\n/**\n * Creates and returns an event handler function for the \"AUTHORIZED\" event. The handler function manages the authorization process for the given RemoteCommunication instance.\n *\n * This function performs several tasks:\n * 1. Skips processing if the instance is already authorized.\n * 2. Ensures the wallet version info is available, polling if necessary.\n * 3. Implements backward compatibility for wallets with versions earlier than 7.3. It checks against a hardcoded version to decide whether to proceed with the event handling.\n * 4. Identifies if the platform is considered \"secure\" based on predefined platform types.\n * 5. If on a secure platform, the instance's state is updated to indicate it's authorized and the \"AUTHORIZED\" event is emitted.\n *\n * @param instance The instance of RemoteCommunication to be processed.\n * @returns A function which acts as the event handler for the \"AUTHORIZED\" event.\n */\nexport function handleAuthorizedEvent(instance: RemoteCommunication) {\n  return async () => {\n    const { state } = instance;\n\n    if (state.authorized) {\n      // Ignore duplicate event or already authorized\n      return;\n    }\n\n    // Sometime the wallet version is not yet received upon authorized message\n    const waitForWalletVersion = async () => {\n      while (!state.walletInfo) {\n        await wait(500);\n      }\n    };\n    await waitForWalletVersion();\n\n    // The event might be received twice because of a backward compatibility hack in SocketService.\n    // bacward compatibility for wallet <7.3\n    const compareValue = '7.3'.localeCompare(state.walletInfo?.version || '');\n\n    if (state.debug) {\n      console.debug(\n        `RemoteCommunication HACK 'authorized' version=${state.walletInfo?.version} compareValue=${compareValue}`,\n      );\n    }\n\n    // FIXME remove this hack pending wallet release 7.3+\n    if (compareValue !== 1) {\n      // ignore for version 7.3+\n      return;\n    }\n\n    const isSecurePlatform =\n      state.platformType === PlatformType.MobileWeb ||\n      state.platformType === PlatformType.ReactNative ||\n      state.platformType === PlatformType.MetaMaskMobileWebview;\n\n    if (state.debug) {\n      console.debug(\n        `RemoteCommunication HACK 'authorized' platform=${state.platformType} secure=${isSecurePlatform} channel=${state.channelId} walletVersion=${state.walletInfo?.version}`,\n      );\n    }\n\n    if (isSecurePlatform) {\n      // Propagate authorized event.\n      state.authorized = true;\n      instance.emit(EventType.AUTHORIZED);\n    }\n  };\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { EventType } from '../../../types/EventType';\n\n/**\n * Creates and returns an event handler function for the \"CHANNEL_CREATED\" event. This handler function manages the channel creation process for a given RemoteCommunication instance.\n *\n * Upon receiving the \"CHANNEL_CREATED\" event:\n * 1. If debugging is enabled, the event details are logged for diagnostics.\n * 2. The \"CHANNEL_CREATED\" event is emitted, passing along the channel ID, to inform other parts of the system that a channel has been successfully created.\n *\n * @param instance The instance of RemoteCommunication to be processed.\n * @returns A function which acts as the event handler for the \"CHANNEL_CREATED\" event.\n */\nexport function handleChannelCreatedEvent(instance: RemoteCommunication) {\n  return (id: string) => {\n    const { state } = instance;\n    if (state.debug) {\n      console.debug(\n        `RemoteCommunication::${state.context}::on 'channel_created' channelId=${id}`,\n      );\n    }\n    instance.emit(EventType.CHANNEL_CREATED, id);\n  };\n}\n","import packageJson from '../../../../package.json';\nimport { SendAnalytics } from '../../../Analytics';\nimport { RemoteCommunication } from '../../../RemoteCommunication';\nimport { CommunicationLayerPreference } from '../../../types/CommunicationLayerPreference';\nimport { EventType } from '../../../types/EventType';\nimport { TrackingEvents } from '../../../types/TrackingEvent';\n\n/**\n * Creates and returns an event handler function for the \"CLIENTS_CONNECTED\" event. This handler function manages the connected clients for a given RemoteCommunication instance.\n *\n * When clients successfully connect:\n * 1. If debugging is enabled, the event details (channel ID and keys exchanged status) are logged for diagnostics.\n * 2. If analytics tracking is enabled, the analytics data is collected and sent to the server. This data includes the SDK version, wallet version, communication layer version, and other relevant information.\n * 3. The state of the RemoteCommunication instance is updated to reflect that clients have successfully connected and that the originator information hasn't been sent yet.\n * 4. The \"CLIENTS_CONNECTED\" event is emitted to inform other parts of the system about the successful connection of clients.\n *\n * @param instance The instance of RemoteCommunication for which the event handler function is being created.\n * @param communicationLayerPreference The preferred communication layer used for this connection.\n * @returns A function that acts as the event handler for the \"CLIENTS_CONNECTED\" event.\n */\nexport function handleClientsConnectedEvent(\n  instance: RemoteCommunication,\n  communicationLayerPreference: CommunicationLayerPreference,\n) {\n  return () => {\n    const { state } = instance;\n    // Propagate the event to manage different loading states on the ui.\n    if (state.debug) {\n      console.debug(\n        `RemoteCommunication::on 'clients_connected' channel=${\n          state.channelId\n        } keysExchanged=${\n          state.communicationLayer?.getKeyInfo()?.keysExchanged\n        }`,\n      );\n    }\n\n    if (state.analytics) {\n      const requestEvent = state.isOriginator\n        ? TrackingEvents.REQUEST\n        : TrackingEvents.REQUEST_MOBILE;\n      SendAnalytics(\n        {\n          id: state.channelId ?? '',\n          event: state.reconnection ? TrackingEvents.RECONNECT : requestEvent,\n          ...state.originatorInfo,\n          commLayer: communicationLayerPreference,\n          sdkVersion: state.sdkVersion,\n          walletVersion: state.walletInfo?.version,\n          commLayerVersion: packageJson.version,\n        },\n        state.communicationServerUrl,\n      ).catch((err) => {\n        console.error(`Cannot send analytics`, err);\n      });\n    }\n\n    state.clientsConnected = true;\n    state.originatorInfoSent = false; // Always re-send originator info.\n    instance.emit(EventType.CLIENTS_CONNECTED);\n  };\n}\n","import packageJson from '../../../../package.json';\nimport { SendAnalytics } from '../../../Analytics';\nimport { RemoteCommunication } from '../../../RemoteCommunication';\nimport { CommunicationLayerPreference } from '../../../types/CommunicationLayerPreference';\nimport { ConnectionStatus } from '../../../types/ConnectionStatus';\nimport { EventType } from '../../../types/EventType';\nimport { TrackingEvents } from '../../../types/TrackingEvent';\n\n/**\n * Creates and returns an event handler function for the \"CLIENTS_DISCONNECTED\" event. This handler function manages the state and operations when clients get disconnected from a RemoteCommunication instance.\n *\n * Upon client disconnection:\n * 1. If debugging is enabled, logs the channel ID associated with the disconnection event for diagnostics.\n * 2. Updates the `RemoteCommunication` instance state to indicate that clients are no longer connected, sets connection status to \"DISCONNECTED\", and resets the \"ready\" and \"authorized\" flags.\n * 3. Emits a \"CLIENTS_DISCONNECTED\" event to notify other parts of the system about the disconnection. This is useful for managing UI states or triggering certain operations.\n * 4. If analytics tracking is enabled and a channel ID is available, sends disconnection analytics data to the server. This data includes the SDK version, wallet version, communication layer version, and other relevant details.\n *\n * @param instance The instance of RemoteCommunication for which the event handler function is being created.\n * @param communicationLayerPreference The preferred communication layer used for this connection.\n * @returns A function that acts as the event handler for the \"CLIENTS_DISCONNECTED\" event, expecting a channel ID as its parameter.\n */\nexport function handleClientsDisconnectedEvent(\n  instance: RemoteCommunication,\n  communicationLayerPreference: CommunicationLayerPreference,\n) {\n  return (channelId: string) => {\n    const { state } = instance;\n    if (state.debug) {\n      console.debug(\n        `RemoteCommunication::${state.context}]::on 'clients_disconnected' channelId=${channelId}`,\n      );\n    }\n\n    state.clientsConnected = false;\n\n    // Propagate the disconnect event to clients.\n    instance.emit(EventType.CLIENTS_DISCONNECTED, state.channelId);\n    instance.setConnectionStatus(ConnectionStatus.DISCONNECTED);\n\n    state.ready = false;\n    state.authorized = false;\n\n    if (state.analytics && state.channelId) {\n      SendAnalytics(\n        {\n          id: state.channelId,\n          event: TrackingEvents.DISCONNECTED,\n          sdkVersion: state.sdkVersion,\n          commLayer: communicationLayerPreference,\n          commLayerVersion: packageJson.version,\n          walletVersion: state.walletInfo?.version,\n        },\n        state.communicationServerUrl,\n      ).catch((err) => {\n        console.error(`Cannot send analytics`, err);\n      });\n    }\n  };\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { ConnectionStatus } from '../../../types/ConnectionStatus';\nimport { EventType } from '../../../types/EventType';\n\n/**\n * Creates and returns an event handler function for the \"CLIENTS_WAITING\" event. This handler manages state and operations when clients are in a waiting state within a `RemoteCommunication` instance.\n *\n * Upon client entering the waiting state:\n * 1. If debugging is enabled, logs diagnostic information such as the number of users waiting, current connection readiness, and if the originator connection has started automatically.\n * 2. Updates the `RemoteCommunication` instance state to \"WAITING\".\n * 3. Emits a \"CLIENTS_WAITING\" event to notify other parts of the system about the waiting clients. The number of waiting users is passed as an argument, which can be useful for managing UI states or triggering certain operations.\n * 4. If the originator connection started automatically, a timer is set based on the provided timeout (defaulting to 3 seconds if none is provided). When this timer expires:\n *    a. The connection's status is checked. If it hasn't transitioned to \"ready\", the connection status is updated to \"TIMEOUT\".\n *    b. The timer is cleared to prevent any further actions.\n *\n * @param instance The `RemoteCommunication` instance for which the event handler function is being created.\n * @returns A function that acts as the event handler for the \"CLIENTS_WAITING\" event, expecting the number of waiting users as its parameter.\n */\nexport function handleClientsWaitingEvent(instance: RemoteCommunication) {\n  return (numberUsers: number) => {\n    const { state } = instance;\n\n    if (state.debug) {\n      console.debug(\n        `RemoteCommunication::${state.context}::on 'clients_waiting' numberUsers=${numberUsers} ready=${state.ready} autoStarted=${state.originatorConnectStarted}`,\n      );\n    }\n\n    instance.setConnectionStatus(ConnectionStatus.WAITING);\n\n    instance.emit(EventType.CLIENTS_WAITING, numberUsers);\n    if (state.originatorConnectStarted) {\n      if (state.debug) {\n        console.debug(\n          `RemoteCommunication::on 'clients_waiting' watch autoStarted=${state.originatorConnectStarted} timeout`,\n          state.autoConnectOptions,\n        );\n      }\n\n      const timeout = state.autoConnectOptions?.timeout || 3000;\n      const timeoutId = setTimeout(() => {\n        if (state.debug) {\n          console.debug(\n            `RemoteCommunication::on setTimeout(${timeout}) terminate channelConfig`,\n            state.autoConnectOptions,\n          );\n        }\n        // Cleanup previous channelId\n        // state.storageManager?.terminate();\n        state.originatorConnectStarted = false;\n        if (!state.ready) {\n          instance.setConnectionStatus(ConnectionStatus.TIMEOUT);\n        }\n        clearTimeout(timeoutId);\n      }, timeout);\n    }\n  };\n}\n","import packageJson from '../../../../package.json';\nimport { SendAnalytics } from '../../../Analytics';\nimport { RemoteCommunication } from '../../../RemoteCommunication';\nimport { CommunicationLayerPreference } from '../../../types/CommunicationLayerPreference';\nimport { ConnectionStatus } from '../../../types/ConnectionStatus';\nimport { MessageType } from '../../../types/MessageType';\nimport { OriginatorInfo } from '../../../types/OriginatorInfo';\nimport { TrackingEvents } from '../../../types/TrackingEvent';\nimport { setLastActiveDate } from '../StateManger';\n\n/**\n * Creates and returns an event handler function for the \"keys_exchanged\" event. This handler is responsible for managing the state and operations associated with the key exchange process within a `RemoteCommunication` instance.\n *\n * Upon successful key exchange:\n * 1. Diagnostic information is logged if debugging is enabled.\n * 2. If keys have been successfully exchanged, the connection status of the `RemoteCommunication` instance is set to \"LINKED\".\n * 3. The last active date for the instance is updated.\n * 4. Analytics data is sent, if applicable, including details such as the SDK version, communication layer preference, package version, and wallet version.\n * 5. The state variable `isOriginator` is updated based on the incoming message.\n * 6. If the current instance is not the originator:\n *    a. It avoids sending the originator message from the wallet side.\n *    b. A message of type \"READY\" is sent to notify that the connection is ready.\n *    c. The instance's readiness and paused states are updated.\n * 7. For backward compatibility, if the instance is the originator and the originator information has not been sent:\n *    a. A message of type \"ORIGINATOR_INFO\" is sent containing the originator details.\n *    b. The state variable `originatorInfoSent` is updated to indicate that the originator information has been transmitted.\n *\n * @param instance The `RemoteCommunication` instance for which the event handler function is being created.\n * @param communicationLayerPreference The communication layer preference, used for analytics.\n * @returns A function that acts as the event handler for the \"keys_exchanged\" event, expecting a message containing details about the key exchange.\n */\nexport function handleKeysExchangedEvent(\n  instance: RemoteCommunication,\n  communicationLayerPreference: CommunicationLayerPreference,\n) {\n  return (message: {\n    isOriginator: boolean;\n    originatorInfo: OriginatorInfo;\n    originator: OriginatorInfo;\n  }) => {\n    const { state } = instance;\n\n    if (state.debug) {\n      console.debug(\n        `RemoteCommunication::${state.context}::on commLayer.'keys_exchanged' channel=${state.channelId}`,\n        message,\n      );\n    }\n\n    if (state.communicationLayer?.getKeyInfo()?.keysExchanged) {\n      instance.setConnectionStatus(ConnectionStatus.LINKED);\n    }\n\n    setLastActiveDate(instance, new Date());\n\n    if (state.analytics && state.channelId) {\n      SendAnalytics(\n        {\n          id: state.channelId,\n          event: message.isOriginator\n            ? TrackingEvents.CONNECTED\n            : TrackingEvents.CONNECTED_MOBILE,\n          sdkVersion: state.sdkVersion,\n          commLayer: communicationLayerPreference,\n          commLayerVersion: packageJson.version,\n          walletVersion: state.walletInfo?.version,\n        },\n        state.communicationServerUrl,\n      ).catch((err) => {\n        console.error(`Cannot send analytics`, err);\n      });\n    }\n\n    state.isOriginator = message.isOriginator;\n\n    if (!message.isOriginator) {\n      // Don't send originator message from wallet.\n      // Always Tell the DAPP metamask is ready\n      // the dapp will send originator message when receiving ready.\n      state.communicationLayer?.sendMessage({\n        type: MessageType.READY,\n      });\n      state.ready = true;\n      state.paused = false;\n    }\n\n    // Keep sending originator info from this location for backward compatibility\n    if (message.isOriginator && !state.originatorInfoSent) {\n      // Always re-send originator info in case the session was deleted on the wallet\n      state.communicationLayer?.sendMessage({\n        type: MessageType.ORIGINATOR_INFO,\n        originatorInfo: state.originatorInfo,\n        originator: state.originatorInfo,\n      });\n      state.originatorInfoSent = true;\n    }\n  };\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { ChannelConfig } from '../../../types/ChannelConfig';\n\n/**\n * Updates the last active date for a given `RemoteCommunication` instance and persists the\n * updated channel configuration.\n *\n * The function creates a new channel configuration (`ChannelConfig`) using the `channelId`\n * and `validUntil` values from the instance's state and the provided `lastActiveDate`.\n * This new configuration is then persisted using the instance's `storageManager`.\n *\n * If `debug` mode is enabled in the instance's state, the function logs the current channel\n * and the provided last active date.\n *\n * @param instance The `RemoteCommunication` instance whose channel configuration is to be updated.\n * @param lastActiveDate The date to set as the last active date.\n */\nexport function setLastActiveDate(\n  instance: RemoteCommunication,\n  lastActiveDate: Date,\n) {\n  const { state } = instance;\n\n  if (state.debug) {\n    console.debug(\n      `RemoteCommunication::setLastActiveDate() channel=${state.channelId}`,\n      lastActiveDate,\n    );\n  }\n  const newChannelConfig: ChannelConfig = {\n    channelId: state.channelId ?? '',\n    validUntil: state.channelConfig?.validUntil ?? 0,\n    lastActive: lastActiveDate.getTime(),\n  };\n  state.storageManager?.persistChannelConfig(newChannelConfig);\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { CommunicationLayerMessage } from '../../../types/CommunicationLayerMessage';\nimport { EventType } from '../../../types/EventType';\nimport { MessageType } from '../../../types/MessageType';\nimport { handleAuthorizedMessage } from './handleAuthorizedMessage';\nimport { handleOriginatorInfoMessage } from './handleOriginatorInfoMessage';\nimport { handleOtpMessage } from './handleOtpMessage';\nimport { handlePauseMessage } from './handlePauseMessage';\nimport { handleReadyMessage } from './handleReadyMessage';\nimport { handleTerminateMessage } from './handleTerminateMessage';\nimport { handleWalletInfoMessage } from './handleWalletInfoMessage';\n\n/**\n * Central dispatcher function to handle messages for a `RemoteCommunication` instance.\n *\n * The function takes a message of type `CommunicationLayerMessage` and a `RemoteCommunication` instance\n * and based on the `message.type` decides which specific handler function should be invoked.\n *\n * Steps taken by the function:\n *\n * 1. Logs the incoming message if `debug` mode is enabled.\n * 2. Sets the `ready` status of the instance to `true`.\n * 3. Checks the `message.type` and the `isOriginator` status of the instance to determine the relevant handler.\n * 4. Invokes the specific handler function based on the determined conditions.\n * 5. If the message doesn't match specific criteria, it emits a general `MESSAGE` event.\n *\n * @param message The incoming `CommunicationLayerMessage` that needs to be processed.\n * @param instance The `RemoteCommunication` instance that is the target of the message.\n */\nexport function onCommunicationLayerMessage(\n  message: CommunicationLayerMessage,\n  instance: RemoteCommunication,\n) {\n  const { state } = instance;\n  if (state.debug) {\n    console.debug(\n      `RemoteCommunication::${\n        state.context\n      }::on 'message' typeof=${typeof message}`,\n      message,\n    );\n  }\n\n  instance.state.ready = true;\n\n  if (!state.isOriginator && message.type === MessageType.ORIGINATOR_INFO) {\n    handleOriginatorInfoMessage(instance, message);\n    return;\n  } else if (state.isOriginator && message.type === MessageType.WALLET_INFO) {\n    handleWalletInfoMessage(instance, message);\n    return;\n  } else if (message.type === MessageType.TERMINATE) {\n    handleTerminateMessage(instance);\n  } else if (message.type === MessageType.PAUSE) {\n    handlePauseMessage(instance);\n  } else if (message.type === MessageType.READY && state.isOriginator) {\n    handleReadyMessage(instance);\n  } else if (message.type === MessageType.OTP && state.isOriginator) {\n    handleOtpMessage(instance, message);\n    return;\n  } else if (message.type === MessageType.AUTHORIZED && state.isOriginator) {\n    handleAuthorizedMessage(instance);\n  }\n\n  // TODO should it check if only emitting JSON-RPC message?\n  instance.emit(EventType.MESSAGE, message);\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { CommunicationLayerMessage } from '../../../types/CommunicationLayerMessage';\n\n/**\n * Handles the 'walletInfo' message for a `RemoteCommunication` instance.\n *\n * When a 'walletInfo' message is received, this function is responsible for updating the current `RemoteCommunication`\n * instance's state with the received wallet information and resetting the paused state of the instance.\n *\n * The sequence of actions taken on receiving a 'walletInfo' message is as follows:\n *\n * 1. Update the `walletInfo` property of the instance's state with the `walletInfo` received in the message.\n * 2. Reset the `paused` status of the instance to `false`.\n *\n * Previously, there was some additional code (commented out) that handled a specific backward compatibility scenario.\n * When the wallet version was less than '6.6', an AUTHORIZED event was simulated, ensuring compatibility with older\n * versions. This backward compatibility code has been deprecated and is preserved in comments for reference purposes.\n *\n * @param instance The `RemoteCommunication` instance that needs to be acted upon when a walletInfo message is received.\n * @param message The `CommunicationLayerMessage` object containing the wallet information.\n */\nexport function handleWalletInfoMessage(\n  instance: RemoteCommunication,\n  message: CommunicationLayerMessage,\n) {\n  const { state } = instance;\n\n  state.walletInfo = message.walletInfo;\n  state.paused = false;\n\n  // FIXME Remove comment --- but keep temporarily for reference in case of quick rollback\n  // if ('6.6'.localeCompare(state.walletInfo?.version || '') === 1) {\n  //   // SIMULATE AUTHORIZED EVENT\n  //   // FIXME remove hack as soon as ios release 7.x is out\n  //   state.authorized = true;\n  //   emit(EventType.AUTHORIZED);\n\n  //   if (state.debug) {\n  //     // Check for backward compatibility\n  //     console.debug(\n  //       `wallet version ${state.walletInfo?.version} -- Force simulate AUTHORIZED event`,\n  //       state.walletInfo,\n  //     );\n  //   }\n  // }\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { EventType } from '../../../types/EventType';\nimport { disconnect } from '../ConnectionManager';\n\n/**\n * Handles the 'terminate' message for a `RemoteCommunication` instance.\n *\n * The termination process is initiated when a 'terminate' message is received. The purpose of this function is to ensure\n * that the communication channel is closed and the associated configurations are removed from persistence, specifically\n * when the current instance is the originator of the communication.\n *\n * The sequence of actions taken on receiving a 'terminate' message is as follows:\n *\n * 1. Check if the current instance is the originator. If not, this function will not proceed further.\n * 2. If it is the originator, call the `disconnect` function with options to terminate the channel without sending a\n *    'terminate' message back (to avoid recursive termination).\n * 3. Output a debug message to the console. (Note: The `console.debug()` call seems to be missing its arguments. It\n *    should ideally print a meaningful message regarding the termination process.)\n * 4. Emit a `TERMINATE` event to inform other parts of the system that the channel has been terminated.\n *\n * @param instance The `RemoteCommunication` instance that needs to be acted upon when a terminate message is received.\n */\nexport function handleTerminateMessage(instance: RemoteCommunication) {\n  const { state } = instance;\n\n  // remove channel config from persistence layer and close active connections.\n  if (state.isOriginator) {\n    disconnect({\n      options: { terminate: true, sendMessage: false },\n      instance,\n    });\n    console.debug();\n    instance.emit(EventType.TERMINATE);\n  }\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { ConnectionStatus } from '../../../types/ConnectionStatus';\n/**\n * Handles the pause message for a `RemoteCommunication` instance.\n *\n * When the system receives a pause message, this function updates the current state of the `RemoteCommunication` instance by:\n *\n * 1. Marking the communication as paused (`state.paused = true`).\n * 2. Updating the connection status to `ConnectionStatus.PAUSED`.\n *\n * The pause functionality can be useful in situations where communication needs to be temporarily halted without terminating the connection. This can be due to various reasons, such as waiting for user input, network interruptions, or other operational considerations.\n *\n * @param instance The `RemoteCommunication` instance whose state needs to be updated in response to a pause message.\n */\nexport function handlePauseMessage(instance: RemoteCommunication) {\n  const { state } = instance;\n\n  state.paused = true;\n  instance.setConnectionStatus(ConnectionStatus.PAUSED);\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { ConnectionStatus } from '../../../types/ConnectionStatus';\nimport { EventType } from '../../../types/EventType';\n\n/**\n * Handles the 'ready' message for a `RemoteCommunication` instance.\n *\n * When the system receives a 'ready' message, this function performs the following actions:\n *\n * 1. Updates the connection status to `ConnectionStatus.LINKED`, indicating that a successful link has been established.\n * 2. Checks the current paused status. If the system was in a paused state, it keeps track of this status so that subsequent actions can be aware of the resumed state.\n * 3. Resets the paused status to indicate that the communication is no longer paused.\n * 4. Emits a `CLIENTS_READY` event with information about the originator and wallet to notify other parts of the system.\n * 5. If the system was previously in a paused state (resumed), it assumes that the connection is authorized. As a result, the authorized status is set to true, and an `AUTHORIZED` event is emitted.\n *\n * @param instance The `RemoteCommunication` instance whose state needs to be updated in response to a ready message.\n */\nexport function handleReadyMessage(instance: RemoteCommunication) {\n  const { state } = instance;\n\n  instance.setConnectionStatus(ConnectionStatus.LINKED);\n\n  // keep track of resumed state before resetting it and emitting messages\n  // Better to reset the paused status before emitting as otherwise it may interfer.\n  const resumed = state.paused;\n  // Reset paused status\n  state.paused = false;\n\n  instance.emit(EventType.CLIENTS_READY, {\n    isOriginator: state.isOriginator,\n    walletInfo: state.walletInfo,\n  });\n\n  if (resumed) {\n    state.authorized = true;\n    // If connection is resumed, automatically assume authorized.\n    instance.emit(EventType.AUTHORIZED);\n  }\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { RPC_METHODS } from '../../../config';\nimport { CommunicationLayerMessage } from '../../../types/CommunicationLayerMessage';\nimport { EventType } from '../../../types/EventType';\n\n/**\n * Handles the OTP (One-Time Password) message for a `RemoteCommunication` instance.\n *\n * When a message contains an OTP, this function manages the OTP authentication process and ensures compatibility with older versions of the system. Specifically, it:\n *\n * 1. Emits the received OTP answer, making it available to any interested listeners.\n * 2. Checks the version of the wallet currently communicating with the system.\n *    - If the wallet version is below 6.6, the function triggers the `eth_requestAccounts` RPC call for backward compatibility. This is likely because older wallet versions (below 6.6) required an additional step in the OTP authentication process that newer versions might have eliminated or modified.\n *\n * @param instance The `RemoteCommunication` instance on which the OTP message is processed.\n * @param message The received `CommunicationLayerMessage` containing the OTP answer.\n */\nexport function handleOtpMessage(\n  instance: RemoteCommunication,\n  message: CommunicationLayerMessage,\n) {\n  const { state } = instance;\n\n  // OTP message are ignored on the wallet.\n  instance.emit(EventType.OTP, message.otpAnswer);\n\n  // backward compatibility for wallet <6.6\n  if ('6.6'.localeCompare(state.walletInfo?.version || '') === 1) {\n    console.warn(\n      `RemoteCommunication::on 'otp' -- backward compatibility <6.6 -- triger eth_requestAccounts`,\n    );\n\n    instance.emit(EventType.SDK_RPC_CALL, {\n      method: RPC_METHODS.ETH_REQUESTACCOUNTS,\n      params: [],\n    });\n  }\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { EventType } from '../../../types/EventType';\n\n/**\n * Processes the authorized message for a `RemoteCommunication` instance.\n *\n * When the `handleAuthorizedMessage` function is invoked, it performs the following actions:\n * 1. It updates the `authorized` property of the `RemoteCommunication` instance state to true. This marks the instance as authorized.\n * 2. Emits an `AUTHORIZED` event, which can be listened to by other parts of the application. This event notifies listeners that the instance has successfully been authorized.\n *\n * This function is typically used when the application receives an authorization confirmation, indicating that the necessary authentication and authorization checks have been successfully completed.\n *\n * @param instance The `RemoteCommunication` instance on which the authorized message is processed.\n */\nexport function handleAuthorizedMessage(instance: RemoteCommunication) {\n  const { state } = instance;\n\n  state.authorized = true;\n  instance.emit(EventType.AUTHORIZED);\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { CommunicationLayerMessage } from '../../../types/CommunicationLayerMessage';\nimport { EventType } from '../../../types/EventType';\nimport { MessageType } from '../../../types/MessageType';\n\n/**\n * Handles the originator information message for a `RemoteCommunication` instance.\n *\n * The originator information message is typically used to exchange identification information between peers or entities within the communication process. This function achieves the following:\n *\n * 1. It sends back a `WALLET_INFO` message type containing the wallet information stored in the instance state. This step is useful for the receiver to identify and understand the capabilities and version of the wallet that is currently communicating.\n * 2. It updates the `originatorInfo` property of the `RemoteCommunication` instance state with the received originator information from the message. This provides a reference to the sender's identification information for future interactions.\n * 3. It emits a `CLIENTS_READY` event with relevant data, which can be consumed by listeners to know when the clients (i.e., both the sender and receiver) are ready for communication.\n * 4. It sets the `paused` state of the instance to `false`, indicating active communication.\n *\n * @param instance The `RemoteCommunication` instance on which the originator information message is processed.\n * @param message The received `CommunicationLayerMessage` containing the originator information.\n */\nexport function handleOriginatorInfoMessage(\n  instance: RemoteCommunication,\n  message: CommunicationLayerMessage,\n) {\n  const { state } = instance;\n\n  // TODO why these hardcoded value?\n  state.communicationLayer?.sendMessage({\n    type: MessageType.WALLET_INFO,\n    walletInfo: state.walletInfo,\n  });\n  state.originatorInfo = message.originatorInfo || message.originator;\n  instance.emit(EventType.CLIENTS_READY, {\n    isOriginator: state.isOriginator,\n    originatorInfo: state.originatorInfo,\n  });\n  state.paused = false;\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { CommunicationLayerMessage } from '../../../types/CommunicationLayerMessage';\nimport { EventType } from '../../../types/EventType';\nimport { handleAuthorization } from '../ConnectionManager';\n\n/**\n * Asynchronously sends a message using the given `RemoteCommunication` instance.\n *\n * The function first checks if the system is in an appropriate state to send the message.\n * This includes ensuring that the communication isn't paused, the system is ready,\n * it's connected, and the clients are also connected.\n *\n * If the system isn't in a ready state, the function waits for the `CLIENTS_READY` event\n * to be emitted, signaling that it can proceed with sending the message. Once this event\n * is triggered, the function tries to authorize and send the message.\n *\n * If the system is already in a ready state, it proceeds directly to authorize and send\n * the message, handling any potential errors.\n *\n * If `debug` mode is enabled, the function logs crucial information, providing visibility\n * into its operations, which can be valuable for debugging.\n *\n * @param instance The `RemoteCommunication` instance used to send the message.\n * @param message The message of type `CommunicationLayerMessage` to be sent.\n * @returns A Promise that resolves once the message is sent or rejects with an error.\n */\nexport async function sendMessage(\n  instance: RemoteCommunication,\n  message: CommunicationLayerMessage,\n): Promise<void> {\n  const { state } = instance;\n\n  if (state.debug) {\n    console.log(\n      `RemoteCommunication::${state.context}::sendMessage paused=${\n        state.paused\n      } ready=${state.ready} authorized=${\n        state.authorized\n      } socket=${state.communicationLayer?.isConnected()} clientsConnected=${\n        state.clientsConnected\n      } status=${state._connectionStatus}`,\n      message,\n    );\n  }\n\n  if (\n    state.paused ||\n    !state.ready ||\n    !state.communicationLayer?.isConnected() ||\n    !state.clientsConnected\n  ) {\n    if (state.debug) {\n      console.log(\n        `RemoteCommunication::${state.context}::sendMessage  SKIP message waiting for MM mobile readiness.`,\n      );\n    }\n\n    await new Promise<void>((resolve) => {\n      instance.once(EventType.CLIENTS_READY, resolve);\n    });\n\n    if (state.debug) {\n      console.log(\n        `RemoteCommunication::${state.context}::sendMessage  AFTER SKIP / READY -- sending pending message`,\n      );\n    }\n  }\n\n  try {\n    await handleAuthorization(instance, message);\n  } catch (err) {\n    console.error(\n      `RemoteCommunication::${state.context}::sendMessage  ERROR`,\n      err,\n    );\n    throw err;\n  }\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { CommunicationLayerMessage } from '../../../types/CommunicationLayerMessage';\nimport { EventType } from '../../../types/EventType';\n\n/**\n * Manages the message authorization process for a RemoteCommunication instance. It ensures that only authorized messages are sent through the communication layer. For backwards compatibility, messages sent by wallets older than version 7.3 are also handled.\n *\n * @param instance The current instance of the RemoteCommunication class.\n * @param message The message from the CommunicationLayer that needs authorization before being sent.\n * @returns Promise<void> Resolves when the message has been processed, either by sending it or by ensuring the necessary authorization.\n */\nexport async function handleAuthorization(\n  instance: RemoteCommunication,\n  message: CommunicationLayerMessage,\n): Promise<void> {\n  return new Promise((resolve) => {\n    const { state } = instance;\n\n    if (state.debug) {\n      console.log(\n        `RemoteCommunication::${state.context}::sendMessage::handleAuthorization ready=${state.ready} authorized=${state.authorized} method=${message.method}`,\n      );\n    }\n\n    // TODO remove after wallet 7.3+ is deployed\n    // backward compatibility for wallet <7.3\n    if ('7.3'.localeCompare(state.walletInfo?.version || '') === 1) {\n      if (state.debug) {\n        console.debug(\n          `compatibility hack wallet version > ${state.walletInfo?.version}`,\n        );\n      }\n      state.communicationLayer?.sendMessage(message);\n      resolve();\n      return;\n    }\n\n    if (!state.isOriginator || state.authorized) {\n      state.communicationLayer?.sendMessage(message);\n      resolve();\n    } else {\n      instance.once(EventType.AUTHORIZED, () => {\n        if (state.debug) {\n          console.log(\n            `RemoteCommunication::${state.context}::sendMessage  AFTER SKIP / AUTHORIZED -- sending pending message`,\n          );\n        }\n        // only send the message after the clients have awaken.\n        state.communicationLayer?.sendMessage(message);\n        resolve();\n      });\n    }\n  });\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { CommunicationLayerMessage } from '../../../types/CommunicationLayerMessage';\nimport { onCommunicationLayerMessage } from '../MessageHandlers';\n/**\n * Creates and returns an event handler function for the \"message\" event. This handler processes incoming messages intended for a `RemoteCommunication` instance, ensuring they're formatted correctly and delegating to the appropriate message handlers.\n *\n * @param instance The `RemoteCommunication` instance associated with this event handler.\n * @returns A function that acts as the event handler for the \"message\" event, expecting a message of type `CommunicationLayerMessage`.\n */\nexport function handleMessageEvent(instance: RemoteCommunication) {\n  return (_message: CommunicationLayerMessage) => {\n    let message = _message;\n    // check if message is encapsulated for backward compatibility\n    if (_message.message) {\n      message = message.message as CommunicationLayerMessage;\n    }\n    onCommunicationLayerMessage(message, instance);\n  };\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { clean } from '../ChannelManager';\n\n/**\n * Creates and returns an event handler function for the \"socket_reconnect\" event. This handler processes socket reconnection events for a `RemoteCommunication` instance, updating its internal state and performing necessary cleanup.\n *\n * @param instance The `RemoteCommunication` instance associated with this event handler.\n * @returns A function that acts as the event handler for the \"socket_reconnect\" event.\n */\nexport function handleSocketReconnectEvent(instance: RemoteCommunication) {\n  return () => {\n    const { state } = instance;\n\n    if (state.debug) {\n      console.debug(\n        `RemoteCommunication::on 'socket_reconnect' -- reset key exchange status / set ready to false`,\n      );\n    }\n    state.ready = false;\n    clean(state);\n  };\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\n\n/**\n * Creates and returns an event handler function for the \"socket_Disconnected\" event. This handler processes socket disconnection events for a `RemoteCommunication` instance, updating its internal state accordingly.\n *\n * @param instance The `RemoteCommunication` instance associated with this event handler.\n * @returns A function that acts as the event handler for the \"socket_Disconnected\" event.\n */\nexport function handleSocketDisconnectedEvent(instance: RemoteCommunication) {\n  return () => {\n    const { state } = instance;\n\n    if (state.debug) {\n      console.debug(\n        `RemoteCommunication::on 'socket_Disconnected' set ready to false`,\n      );\n    }\n    state.ready = false;\n  };\n}\n","import { v4 as uuidv4 } from 'uuid';\nimport { RemoteCommunication } from '../../../RemoteCommunication';\nimport { ConnectionStatus } from '../../../types/ConnectionStatus';\nimport { DisconnectOptions } from '../../../types/DisconnectOptions';\nimport { MessageType } from '../../../types/MessageType';\n\n/**\n * Handles the disconnection process for a RemoteCommunication instance Depending on the provided options, it can terminate the connection and clear related configurations or simply disconnect.\n *\n * @param options Optional settings that determine how the disconnection is handled. It can specify whether to terminate the connection, send a termination message, or reset the channel ID.\n * @param instance The current instance of the RemoteCommunication class that needs to be disconnected.\n * @returns void\n */\nexport function disconnect({\n  options,\n  instance,\n}: {\n  options?: DisconnectOptions;\n  instance: RemoteCommunication;\n}) {\n  const { state } = instance;\n\n  if (state.debug) {\n    console.debug(\n      `RemoteCommunication::disconnect() channel=${state.channelId}`,\n      options,\n    );\n  }\n\n  state.ready = false;\n  state.paused = false;\n\n  if (options?.terminate) {\n    // remove channel config from persistence layer and close active connections.\n    state.storageManager?.terminate(state.channelId ?? '');\n\n    if (\n      state.communicationLayer?.getKeyInfo().keysExchanged &&\n      options?.sendMessage\n    ) {\n      state.communicationLayer?.sendMessage({\n        type: MessageType.TERMINATE,\n      });\n    }\n\n    state.channelId = uuidv4();\n    options.channelId = state.channelId;\n    state.channelConfig = undefined;\n    state.originatorConnectStarted = false;\n    state.communicationLayer?.disconnect(options);\n    instance.setConnectionStatus(ConnectionStatus.TERMINATED);\n  } else {\n    state.communicationLayer?.disconnect(options);\n    instance.setConnectionStatus(ConnectionStatus.DISCONNECTED);\n  }\n}\n","import { EventEmitter2 } from 'eventemitter2';\nimport packageJson from '../package.json';\nimport { ECIESProps } from './ECIES';\nimport {\n  CHANNEL_MAX_WAITING_TIME,\n  DEFAULT_SERVER_URL,\n  DEFAULT_SESSION_TIMEOUT_MS,\n} from './config';\nimport {\n  clean,\n  generateChannelIdConnect,\n} from './services/RemoteCommunication/ChannelManager';\nimport {\n  connectToChannel,\n  disconnect,\n  initCommunicationLayer,\n  originatorSessionConnect,\n  resume,\n} from './services/RemoteCommunication/ConnectionManager';\nimport { sendMessage } from './services/RemoteCommunication/MessageHandlers';\nimport { testStorage } from './services/RemoteCommunication/StorageManager';\nimport { AutoConnectOptions } from './types/AutoConnectOptions';\nimport { ChannelConfig } from './types/ChannelConfig';\nimport { CommunicationLayer } from './types/CommunicationLayer';\nimport { CommunicationLayerMessage } from './types/CommunicationLayerMessage';\nimport { CommunicationLayerPreference } from './types/CommunicationLayerPreference';\nimport { ConnectionStatus } from './types/ConnectionStatus';\nimport { DappMetadataWithSource } from './types/DappMetadata';\nimport { DisconnectOptions } from './types/DisconnectOptions';\nimport { EventType } from './types/EventType';\nimport { CommunicationLayerLoggingOptions } from './types/LoggingOptions';\nimport { OriginatorInfo } from './types/OriginatorInfo';\nimport { PlatformType } from './types/PlatformType';\nimport { ServiceStatus } from './types/ServiceStatus';\nimport {\n  StorageManager as SessionStorageManager,\n  StorageManagerProps,\n} from './types/StorageManager';\nimport { WalletInfo } from './types/WalletInfo';\n\ntype MetaMaskMobile = 'metamask-mobile';\n\nexport interface RemoteCommunicationProps {\n  platformType: PlatformType | MetaMaskMobile;\n  communicationLayerPreference: CommunicationLayerPreference;\n  otherPublicKey?: string;\n  reconnect?: boolean;\n  dappMetadata?: DappMetadataWithSource;\n  walletInfo?: WalletInfo;\n  transports?: string[];\n  analytics?: boolean;\n  communicationServerUrl?: string;\n  ecies?: ECIESProps;\n  sdkVersion?: string;\n  storage?: StorageManagerProps;\n  context: string;\n  autoConnect?: AutoConnectOptions;\n  logging?: CommunicationLayerLoggingOptions;\n}\n\nexport interface RemoteCommunicationState {\n  ready: boolean;\n  authorized: boolean;\n  isOriginator: boolean;\n  paused: boolean;\n  otherPublicKey?: string;\n  transports?: string[];\n  platformType: PlatformType | MetaMaskMobile;\n  analytics: boolean;\n  channelId?: string;\n  channelConfig?: ChannelConfig;\n  walletInfo?: WalletInfo;\n  communicationLayer?: CommunicationLayer;\n  originatorInfo?: OriginatorInfo;\n  originatorInfoSent: boolean;\n  reconnection: boolean;\n  dappMetadata?: DappMetadataWithSource;\n  communicationServerUrl: string;\n  context: string;\n  storageManager?: SessionStorageManager;\n  storageOptions?: StorageManagerProps;\n  sdkVersion?: string;\n  autoConnectOptions?: AutoConnectOptions;\n  clientsConnected: boolean;\n  sessionDuration: number;\n  originatorConnectStarted: boolean;\n  debug: boolean;\n  logging?: CommunicationLayerLoggingOptions;\n  _connectionStatus: ConnectionStatus;\n}\nexport class RemoteCommunication extends EventEmitter2 {\n  public state: RemoteCommunicationState = {\n    // ready flag is turned on after we receive 'clients_ready' message, meaning key exchange is complete.\n    ready: false,\n    // flag turned on once the connection has been authorized on the wallet.\n    authorized: false,\n    isOriginator: false,\n    paused: false,\n    platformType: 'metamask-mobile',\n    analytics: false,\n    reconnection: false,\n    originatorInfoSent: false,\n    communicationServerUrl: DEFAULT_SERVER_URL,\n    context: '',\n    // Keep track if the other side is connected to the socket\n    clientsConnected: false,\n    sessionDuration: DEFAULT_SESSION_TIMEOUT_MS,\n    // this flag is switched on when the connection is automatically initialized after finding existing channel configuration.\n    originatorConnectStarted: false,\n    debug: false,\n    // Status of the other side of the connection\n    // 1) if I am MetaMask then other is Dapp\n    // 2) If I am Dapp (isOriginator==true) then other side is MetaMask\n    // Should not be set directly, use this.setConnectionStatus() instead to always emit events.\n    _connectionStatus: ConnectionStatus.DISCONNECTED,\n  };\n\n  constructor({\n    platformType,\n    communicationLayerPreference,\n    otherPublicKey,\n    reconnect,\n    walletInfo,\n    dappMetadata,\n    transports,\n    context,\n    ecies,\n    analytics = false,\n    storage,\n    sdkVersion,\n    communicationServerUrl = DEFAULT_SERVER_URL,\n    logging,\n    autoConnect = {\n      timeout: CHANNEL_MAX_WAITING_TIME,\n    },\n  }: RemoteCommunicationProps) {\n    super();\n\n    this.state.otherPublicKey = otherPublicKey;\n    this.state.dappMetadata = dappMetadata;\n    this.state.walletInfo = walletInfo;\n    this.state.transports = transports;\n    this.state.platformType = platformType;\n    this.state.analytics = analytics;\n    this.state.isOriginator = !otherPublicKey;\n    this.state.communicationServerUrl = communicationServerUrl;\n    this.state.context = context;\n    this.state.sdkVersion = sdkVersion;\n\n    this.setMaxListeners(50);\n\n    this.setConnectionStatus(ConnectionStatus.DISCONNECTED);\n    if (storage?.duration) {\n      this.state.sessionDuration = DEFAULT_SESSION_TIMEOUT_MS;\n    }\n    this.state.storageOptions = storage;\n    this.state.autoConnectOptions = autoConnect;\n    this.state.debug = logging?.remoteLayer === true;\n    this.state.logging = logging;\n\n    if (storage?.storageManager) {\n      this.state.storageManager = storage.storageManager;\n    }\n\n    this.initCommunicationLayer({\n      communicationLayerPreference,\n      otherPublicKey,\n      reconnect,\n      ecies,\n      communicationServerUrl,\n    });\n\n    this.emitServiceStatusEvent();\n  }\n\n  private initCommunicationLayer({\n    communicationLayerPreference,\n    otherPublicKey,\n    reconnect,\n    ecies,\n    communicationServerUrl = DEFAULT_SERVER_URL,\n  }: Pick<\n    RemoteCommunicationProps,\n    | 'communicationLayerPreference'\n    | 'otherPublicKey'\n    | 'reconnect'\n    | 'ecies'\n    | 'communicationServerUrl'\n  >) {\n    return initCommunicationLayer({\n      communicationLayerPreference,\n      otherPublicKey,\n      reconnect,\n      ecies,\n      communicationServerUrl,\n      instance: this,\n    });\n  }\n\n  /**\n   * Connect from the dapp using session persistence.\n   */\n  async originatorSessionConnect(): Promise<ChannelConfig | undefined> {\n    const channelConfig = await originatorSessionConnect(this);\n    return channelConfig;\n  }\n\n  async generateChannelIdConnect() {\n    return generateChannelIdConnect(this.state);\n  }\n\n  clean() {\n    return clean(this.state);\n  }\n\n  connectToChannel(channelId: string, withKeyExchange?: boolean) {\n    return connectToChannel({\n      channelId,\n      withKeyExchange,\n      state: this.state,\n    });\n  }\n\n  sendMessage(message: CommunicationLayerMessage): Promise<void> {\n    return sendMessage(this, message);\n  }\n\n  async testStorage() {\n    return testStorage(this.state);\n  }\n\n  getChannelConfig() {\n    return this.state.channelConfig;\n  }\n\n  /**\n   * Check if the connection is ready to handle secure communication.\n   *\n   * @returns boolean\n   */\n  isReady() {\n    return this.state.ready;\n  }\n\n  /**\n   * Check the value of the socket io client.\n   *\n   * @returns boolean\n   */\n  isConnected() {\n    return this.state.communicationLayer?.isConnected();\n  }\n\n  isAuthorized() {\n    return this.state.authorized;\n  }\n\n  isPaused() {\n    return this.state.paused;\n  }\n\n  getCommunicationLayer() {\n    return this.state.communicationLayer;\n  }\n\n  ping() {\n    if (this.state.debug) {\n      console.debug(\n        `RemoteCommunication::ping() channel=${this.state.channelId}`,\n      );\n    }\n\n    this.state.communicationLayer?.ping();\n  }\n\n  keyCheck() {\n    if (this.state.debug) {\n      console.debug(\n        `RemoteCommunication::keyCheck() channel=${this.state.channelId}`,\n      );\n    }\n\n    this.state.communicationLayer?.keyCheck();\n  }\n\n  setConnectionStatus(connectionStatus: ConnectionStatus) {\n    if (this.state._connectionStatus === connectionStatus) {\n      return; // Don't re-emit current status.\n    }\n    this.state._connectionStatus = connectionStatus;\n    this.emit(EventType.CONNECTION_STATUS, connectionStatus);\n    this.emitServiceStatusEvent();\n  }\n\n  private emitServiceStatusEvent() {\n    this.emit(EventType.SERVICE_STATUS, this.getServiceStatus());\n  }\n\n  getConnectionStatus() {\n    return this.state._connectionStatus;\n  }\n\n  getServiceStatus(): ServiceStatus {\n    return {\n      originatorInfo: this.state.originatorInfo,\n      keyInfo: this.getKeyInfo(),\n      connectionStatus: this.state._connectionStatus,\n      channelConfig: this.state.channelConfig,\n      channelId: this.state.channelId,\n    };\n  }\n\n  getKeyInfo() {\n    return this.state.communicationLayer?.getKeyInfo();\n  }\n\n  resetKeys() {\n    this.state.communicationLayer?.resetKeys();\n  }\n\n  setOtherPublicKey(otherPublicKey: string) {\n    const keyExchange = this.state.communicationLayer?.getKeyExchange();\n    if (!keyExchange) {\n      throw new Error('KeyExchange is not initialized.');\n    }\n\n    if (keyExchange.getOtherPublicKey() !== otherPublicKey) {\n      keyExchange.setOtherPublicKey(otherPublicKey);\n    }\n  }\n\n  pause() {\n    if (this.state.debug) {\n      console.debug(\n        `RemoteCommunication::pause() channel=${this.state.channelId}`,\n      );\n    }\n    this.state.communicationLayer?.pause();\n    this.setConnectionStatus(ConnectionStatus.PAUSED);\n  }\n\n  getVersion() {\n    return packageJson.version;\n  }\n\n  resume() {\n    return resume(this);\n  }\n\n  getChannelId() {\n    return this.state.channelId;\n  }\n\n  getRPCMethodTracker() {\n    return this.state.communicationLayer?.getRPCMethodTracker();\n  }\n\n  disconnect(options?: DisconnectOptions) {\n    return disconnect({\n      options,\n      instance: this,\n    });\n  }\n}\n","import packageJson from '../../../../package.json';\nimport { ECIESProps } from '../../../ECIES';\nimport { RemoteCommunication } from '../../../RemoteCommunication';\nimport { SocketService } from '../../../SocketService';\nimport { DEFAULT_SERVER_URL } from '../../../config';\nimport { CommunicationLayerPreference } from '../../../types/CommunicationLayerPreference';\nimport { EventType } from '../../../types/EventType';\nimport { OriginatorInfo } from '../../../types/OriginatorInfo';\nimport {\n  handleAuthorizedEvent,\n  handleChannelCreatedEvent,\n  handleClientsConnectedEvent,\n  handleClientsDisconnectedEvent,\n  handleClientsWaitingEvent,\n  handleKeysExchangedEvent,\n  handleMessageEvent,\n  handleSocketDisconnectedEvent,\n  handleSocketReconnectEvent,\n} from '../EventListeners';\n\ntype CommunicationLayerHandledEvents =\n  | EventType.CLIENTS_CONNECTED\n  | EventType.CLIENTS_DISCONNECTED\n  | EventType.CLIENTS_WAITING\n  | EventType.SOCKET_DISCONNECTED\n  | EventType.SOCKET_RECONNECT\n  | EventType.CHANNEL_CREATED\n  | EventType.KEYS_EXCHANGED\n  | EventType.AUTHORIZED\n  | EventType.MESSAGE\n  | EventType.RPC_UPDATE;\n\n/**\n * Initializes the communication layer for a given RemoteCommunication  This function creates a communication layer based on the provided preference (e.g., SOCKET), sets up originator information, and attaches necessary event listeners.\n *\n * If the dappMetadata is available, this metadata is used to populate originator information such as the URL and name of the dapp.\n * This function also sets up various event listeners to handle different types of events that can occur in the communication layer, ensuring that the RemoteCommunication instance responds appropriately to each event.\n *\n * @param communicationLayerPreference Specifies the preferred communication protocol (e.g., SOCKET).\n * @param otherPublicKey The public key of the other party for communication (if available).\n * @param reconnect Indicates if the communication layer should attempt to reconnect after disconnection.\n * @param ecies The Elliptic Curve Integrated Encryption Scheme properties.\n * @param communicationServerUrl The URL of the communication server, defaults to the value in DEFAULT_SERVER_URL.\n * @param instance The current instance of the RemoteCommunication class.\n * @throws Error when an invalid communication protocol is specified.\n */\nexport function initCommunicationLayer({\n  communicationLayerPreference,\n  otherPublicKey,\n  reconnect,\n  ecies,\n  communicationServerUrl = DEFAULT_SERVER_URL,\n  instance,\n}: {\n  communicationLayerPreference: CommunicationLayerPreference;\n  otherPublicKey?: string;\n  reconnect?: boolean;\n  ecies?: ECIESProps;\n  communicationServerUrl?: string;\n  instance: RemoteCommunication;\n}) {\n  const { state } = instance;\n  // state.communicationLayer?.removeAllListeners();\n\n  switch (communicationLayerPreference) {\n    case CommunicationLayerPreference.SOCKET:\n      state.communicationLayer = new SocketService({\n        communicationLayerPreference,\n        otherPublicKey,\n        reconnect,\n        transports: state.transports,\n        communicationServerUrl,\n        context: state.context,\n        ecies,\n        logging: state.logging,\n      });\n      break;\n    default:\n      throw new Error('Invalid communication protocol');\n  }\n\n  let url = (typeof document !== 'undefined' && document.URL) || '';\n  let title = (typeof document !== 'undefined' && document.title) || '';\n\n  if (state.dappMetadata?.url) {\n    url = state.dappMetadata.url;\n  }\n\n  if (state.dappMetadata?.name) {\n    title = state.dappMetadata.name;\n  }\n\n  const originatorInfo: OriginatorInfo = {\n    url,\n    title,\n    source: state.dappMetadata?.source,\n    // icon: state.dappMetadata?.base64Icon, // TODO re-enable and replace with url\n    platform: state.platformType,\n    apiVersion: packageJson.version,\n  };\n  state.originatorInfo = originatorInfo;\n\n  const eventsMapping: {\n    [key in CommunicationLayerHandledEvents]: (...args: any[]) => void;\n  } = {\n    // TODO AUTHORIZED listeners is only added for backward compatibility with wallet < 7.3\n    [EventType.AUTHORIZED]: handleAuthorizedEvent(instance),\n    [EventType.MESSAGE]: handleMessageEvent(instance),\n    [EventType.CLIENTS_CONNECTED]: handleClientsConnectedEvent(\n      instance,\n      communicationLayerPreference,\n    ),\n    [EventType.KEYS_EXCHANGED]: handleKeysExchangedEvent(\n      instance,\n      communicationLayerPreference,\n    ),\n    [EventType.SOCKET_DISCONNECTED]: handleSocketDisconnectedEvent(instance),\n    [EventType.SOCKET_RECONNECT]: handleSocketReconnectEvent(instance),\n    [EventType.CLIENTS_DISCONNECTED]: handleClientsDisconnectedEvent(\n      instance,\n      communicationLayerPreference,\n    ),\n    [EventType.CHANNEL_CREATED]: handleChannelCreatedEvent(instance),\n    [EventType.CLIENTS_WAITING]: handleClientsWaitingEvent(instance),\n    [EventType.RPC_UPDATE]: () => {\n      // TODO use a separate function to isolate unit tests\n      // propagate RPC_UPDATE event to the SDK\n      instance.emit(EventType.RPC_UPDATE);\n    },\n  };\n\n  for (const [eventType, handler] of Object.entries(eventsMapping)) {\n    try {\n      state.communicationLayer.on(eventType, handler);\n    } catch (error) {\n      console.error(`Error registering handler for ${eventType}:`, error);\n    }\n  }\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\n\n/**\n * Attempts to establish a session connection for an originator based on stored channel configuration.\n * If a storage manager is defined for the given RemoteCommunication instance, this function will retrieve the persisted channel configuration. Based on the configuration and the current state of the communication layer, various actions are taken:\n * - If the socket is already connected, it skips further actions and returns the channel configuration.\n * - If the stored channel configuration is valid (i.e., not expired), the function sets up the necessary state variables and attempts to connect to the channel.\n *\n * This function is particularly useful for re-establishing connections with saved session configurations.\n *\n * @param instance The current instance of the RemoteCommunication class.\n * @returns The channel configuration if available and valid, otherwise undefined.\n */\nexport async function originatorSessionConnect(instance: RemoteCommunication) {\n  const { state } = instance;\n\n  if (!state.storageManager) {\n    if (state.debug) {\n      console.debug(\n        `RemoteCommunication::connect() no storage manager defined - skip`,\n      );\n    }\n    return undefined;\n  }\n\n  const channelConfig = await state.storageManager.getPersistedChannelConfig(\n    state.channelId ?? '',\n  );\n  if (state.debug) {\n    console.debug(\n      `RemoteCommunication::connect() autoStarted=${state.originatorConnectStarted} channelConfig`,\n      channelConfig,\n    );\n  }\n\n  const connected = state.communicationLayer?.isConnected();\n  if (connected) {\n    if (state.debug) {\n      console.debug(\n        `RemoteCommunication::connect() socket already connected - skip`,\n      );\n    }\n    return channelConfig;\n  }\n\n  if (channelConfig) {\n    const validSession = channelConfig.validUntil > Date.now();\n\n    if (validSession) {\n      state.channelConfig = channelConfig;\n      state.originatorConnectStarted = true;\n      state.channelId = channelConfig?.channelId;\n      state.reconnection = true;\n      state.communicationLayer?.connectToChannel({\n        channelId: channelConfig.channelId,\n        isOriginator: true,\n      });\n      return channelConfig;\n    } else if (state.debug) {\n      console.log(`RemoteCommunication::autoConnect Session has expired`);\n    }\n  }\n  state.originatorConnectStarted = false;\n  return undefined;\n}\n","import { RemoteCommunicationState } from '../../../RemoteCommunication';\nimport { clean } from './clean';\n\n/**\n * Generates a new channel ID for the communication layer or reuses an existing one.\n * Also establishes necessary configurations and throws errors if the layer isn't initialized or if the channel is already connected.\n *\n * @param state Current state of the RemoteCommunication class instance.\n * @returns An object containing the channelId and its corresponding public key.\n */\n\nexport function generateChannelIdConnect(state: RemoteCommunicationState) {\n  if (!state.communicationLayer) {\n    throw new Error('communication layer not initialized');\n  }\n\n  if (state.ready) {\n    throw new Error('Channel already connected');\n  }\n\n  if (state.channelId && state.communicationLayer?.isConnected()) {\n    console.warn(\n      `Channel already exists -- interrupt generateChannelId`,\n      state.channelConfig,\n    );\n\n    state.channelConfig = {\n      channelId: state.channelId,\n      validUntil: Date.now() + state.sessionDuration,\n    };\n    state.storageManager?.persistChannelConfig(state.channelConfig);\n\n    return {\n      channelId: state.channelId,\n      pubKey: state.communicationLayer?.getKeyInfo()?.ecies.public,\n    };\n  }\n\n  if (state.debug) {\n    console.debug(`RemoteCommunication::generateChannelId()`);\n  }\n\n  clean(state);\n  const channel = state.communicationLayer.createChannel();\n\n  if (state.debug) {\n    console.debug(\n      `RemoteCommunication::generateChannelId() channel created`,\n      channel,\n    );\n  }\n\n  const channelConfig = {\n    channelId: channel.channelId,\n    validUntil: Date.now() + state.sessionDuration,\n  };\n  state.channelId = channel.channelId;\n  state.channelConfig = channelConfig;\n  // save current channel config\n  state.storageManager?.persistChannelConfig(channelConfig);\n\n  return { channelId: state.channelId, pubKey: channel.pubKey };\n}\n","import { validate } from 'uuid';\nimport { RemoteCommunicationState } from '../../../RemoteCommunication';\nimport { ChannelConfig } from '../../../types/ChannelConfig';\n\n/**\n * Initiates a connection to a specified channel. Validates the channel ID, establishes a new connection if not connected, and sets necessary configurations.\n * Also persists the new channel configuration if a storage manager is available.\n *\n * @param channelId Unique identifier for the channel.\n * @param withKeyExchange Optional flag indicating if key exchange should occur during the connection process.\n * @param state Current state of the RemoteCommunication class instance.\n * @returns void\n */\nexport function connectToChannel({\n  channelId,\n  withKeyExchange,\n  state,\n}: {\n  channelId: string;\n  withKeyExchange?: boolean;\n  state: RemoteCommunicationState;\n}) {\n  if (!validate(channelId)) {\n    console.debug(\n      `RemoteCommunication::${state.context}::connectToChannel() invalid channel channelId=${channelId}`,\n    );\n    throw new Error(`Invalid channel ${channelId}`);\n  }\n\n  if (state.debug) {\n    console.debug(\n      `RemoteCommunication::${state.context}::connectToChannel() channelId=${channelId}`,\n    );\n  }\n\n  if (state.communicationLayer?.isConnected()) {\n    // Adding a check on previous connection to prevent reconnecting during dev when HMR is enabled\n    console.debug(\n      `RemoteCommunication::${state.context}::connectToChannel() already connected - interrup connection.`,\n    );\n    return;\n  }\n\n  state.channelId = channelId;\n  state.communicationLayer?.connectToChannel({\n    channelId,\n    withKeyExchange,\n  });\n  const newChannelConfig: ChannelConfig = {\n    channelId,\n    validUntil: Date.now() + state.sessionDuration,\n  };\n  state.channelConfig = newChannelConfig;\n  state.storageManager?.persistChannelConfig(newChannelConfig);\n}\n","import { RemoteCommunicationState } from '../../../RemoteCommunication';\n\n/**\n * Updates the last active date for a given `RemoteCommunication` instance and persists the\n * updated channel configuration.\n *\n * The function creates a new channel configuration (`ChannelConfig`) using the `channelId`\n * and `validUntil` values from the instance's state and the provided `lastActiveDate`.\n * This new configuration is then persisted using the instance's `storageManager`.\n *\n * If `debug` mode is enabled in the instance's state, the function logs the current channel\n * and the provided last active date.\n *\n * @param instance The `RemoteCommunication` instance whose channel configuration is to be updated.\n * @param lastActiveDate The date to set as the last active date.\n */\nexport async function testStorage(state: RemoteCommunicationState) {\n  const res = await state.storageManager?.getPersistedChannelConfig(\n    state.channelId ?? '',\n  );\n  console.debug(`RemoteCommunication.testStorage() res`, res);\n}\n","import { RemoteCommunication } from '../../../RemoteCommunication';\nimport { ConnectionStatus } from '../../../types/ConnectionStatus';\n\n/**\n * Resumes the communication of a previously paused `RemoteCommunication` instance.\n * This function primarily instructs the underlying communication layer to resume its activities. After resuming, the connection status of the instance is set to 'LINKED'.\n * Debug logs are generated if the debug state is enabled, indicating the current channel being resumed.\n *\n * @param instance The current instance of the RemoteCommunication class.\n */\nexport function resume(instance: RemoteCommunication) {\n  const { state } = instance;\n  if (state.debug) {\n    console.debug(`RemoteCommunication::resume() channel=${state.channelId}`);\n  }\n  state.communicationLayer?.resume();\n  instance.setConnectionStatus(ConnectionStatus.LINKED);\n}\n"],"names":["SendAnalytics","parameters","socketServerUrl","__awaiter","serverUrl","endsWith","body","JSON","stringify","response","crossFetch","method","headers","Accept","text","ECIES","constructor","props","this","enabled","debug","pkey","ecies","PrivateKey","fromHex","console","info","toHex","publicKey","generateECIES","getPublicKey","encrypt","data","otherPublicKey","encryptedString","payload","Buffer","from","encryptedData","toString","err","error","decrypt","decryptedString","getKeyInfo","private","public","DEFAULT_SERVER_URL","DEFAULT_SOCKET_TRANSPORTS","DEFAULT_SESSION_TIMEOUT_MS","RPC_METHODS","METAMASK_GETPROVIDERSTATE","ETH_REQUESTACCOUNTS","clean","state","context","channelConfig","undefined","ready","originatorConnectStarted","ConnectionStatus","EventType","InternalEventType","KeyExchangeMessageType","MessageType","KeyExchange","EventEmitter2","communicationLayer","logging","super","keysExchanged","step","KEY_HANDSHAKE_NONE","myECIES","Object","assign","eciesLayer","myPublicKey","keyExchangeLayer","setOtherPublicKey","on","KEY_EXCHANGE","onKeyExchangeMessage","bind","keyExchangeMsg","message","log","type","KEY_HANDSHAKE_SYN","checkStep","KEY_HANDSHAKE_ACK","pubkey","sendMessage","KEY_HANDSHAKE_SYNACK","emit","KEY_INFO","KEYS_EXCHANGED","resetKeys","start","isOriginator","force","KEY_HANDSHAKE_START","stepList","length","indexOf","Error","setKeysExchanged","areKeysExchanged","getMyPublicKey","getOtherPublicKey","otherPubKey","encryptMessage","decryptMessage","buf","keyInfo","wait","ms","Promise","resolve","setTimeout","waitForRpc","rpcId","rpc","interval","result","startTime","Date","now","hasTimedout","elapsedTime","reconnectSocket","instance","_a","socket","connected","_b","resumed","_c","connect","SOCKET_RECONNECT","_d","JOIN_CHANNEL","channelId","_e","handleDisconnect","reason","manualDisconnect","SOCKET_DISCONNECTED","window","document","hasFocus","then","success","catch","addEventListener","once","checkFocusAndReconnect","channelEventListenerMap","event","handler","_id","clientsPaused","keyExchange","CLIENTS_CONNECTED","_g","clientsConnected","id","CHANNEL_CREATED","CLIENTS_DISCONNECTED","checkSameId","PING","MESSAGE","startsWith","_f","warn","canDecrypt","_j","_l","_m","_h","decryptedMessage","_o","messageReceived","parse","PAUSE","rpcMessage","initialRPCMethod","rpcMethodTracker","timestamp","rpcResult","code","_p","_q","RPC_UPDATE","AUTHORIZED","numberUsers","CLIENTS_WAITING","keyExchangeEventListenerMap","serviceStatus","SERVICE_STATUS","setupChannelListeners","io","attempt","forEach","fullEventName","handleSendMessage","handleKeyHandshake","validateKeyExchange","trackRpcMethod","encryptedMessage","messageToSend","plaintext","hasPlaintext","TERMINATE","encryptAndSendMessage","handleRpcReplies","SocketService","reconnect","communicationLayerPreference","transports","communicationServerUrl","serviceLayer","options","autoConnect","keyExchangeInitParameter","sendPublicKey","createChannel","uuidv4","pubKey","connectToChannel","withKeyExchange","keyCheck","KEY_HANDSHAKE_CHECK","getKeyExchange","ping","READY","pause","disconnect","isConnected","resume","getRPCMethodTracker","terminate","CommunicationLayerPreference","PlatformType","TrackingEvents","AutoConnectType","handleAuthorizedEvent","authorized","walletInfo","waitForWalletVersion","compareValue","localeCompare","version","isSecurePlatform","platformType","MobileWeb","ReactNative","MetaMaskMobileWebview","handleChannelCreatedEvent","handleClientsConnectedEvent","analytics","requestEvent","REQUEST","REQUEST_MOBILE","reconnection","RECONNECT","originatorInfo","commLayer","sdkVersion","walletVersion","commLayerVersion","packageJson","originatorInfoSent","handleClientsDisconnectedEvent","setConnectionStatus","DISCONNECTED","handleClientsWaitingEvent","WAITING","autoConnectOptions","timeout","timeoutId","TIMEOUT","clearTimeout","handleKeysExchangedEvent","LINKED","lastActiveDate","newChannelConfig","validUntil","lastActive","getTime","storageManager","persistChannelConfig","setLastActiveDate","CONNECTED","CONNECTED_MOBILE","paused","ORIGINATOR_INFO","originator","onCommunicationLayerMessage","WALLET_INFO","handleWalletInfoMessage","handleTerminateMessage","PAUSED","handlePauseMessage","CLIENTS_READY","handleReadyMessage","OTP","otpAnswer","SDK_RPC_CALL","params","handleOtpMessage","handleAuthorizedMessage","handleOriginatorInfoMessage","_connectionStatus","handleAuthorization","handleMessageEvent","_message","handleSocketReconnectEvent","handleSocketDisconnectedEvent","TERMINATED","RemoteCommunication","dappMetadata","storage","sessionDuration","setMaxListeners","duration","storageOptions","remoteLayer","initCommunicationLayer","emitServiceStatusEvent","SOCKET","url","URL","title","name","source","platform","apiVersion","eventsMapping","eventType","entries","originatorSessionConnect","getPersistedChannelConfig","generateChannelIdConnect","channel","validate","testStorage","res","getChannelConfig","isReady","isAuthorized","isPaused","getCommunicationLayer","connectionStatus","CONNECTION_STATUS","getServiceStatus","getConnectionStatus","getVersion","getChannelId"],"mappings":"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"}