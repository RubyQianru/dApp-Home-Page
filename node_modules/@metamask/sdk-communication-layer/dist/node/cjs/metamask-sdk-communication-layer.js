"use strict";var e=require("cross-fetch"),t=require("buffer"),n=require("eciesjs"),o=require("eventemitter2"),s=require("uuid"),i=require("socket.io-client");function a(e,t,n,o){return new(n||(n=Promise))((function(s,i){function a(e){try{r(o.next(e))}catch(e){i(e)}}function c(e){try{r(o.throw(e))}catch(e){i(e)}}function r(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,c)}r((o=o.apply(e,t||[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;const c=(t,n)=>a(void 0,void 0,void 0,(function*(){const o=n.endsWith("/")?`${n}debug`:`${n}/debug`,s=JSON.stringify(t),i=yield e(o,{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:s});return yield i.text()}));class r{constructor(e){this.enabled=!0,this.debug=!1,(null==e?void 0:e.debug)&&(this.debug=e.debug),(null==e?void 0:e.pkey)?this.ecies=n.PrivateKey.fromHex(e.pkey):this.ecies=new n.PrivateKey,this.debug&&(console.info("[ECIES] initialized secret: ",this.ecies.toHex()),console.info("[ECIES] initialized public: ",this.ecies.publicKey.toHex()),console.info("[ECIES] init with",this))}generateECIES(){this.ecies=new n.PrivateKey}getPublicKey(){return this.ecies.publicKey.toHex()}encrypt(e,o){let s=e;if(this.enabled)try{this.debug&&console.debug("ECIES::encrypt() using otherPublicKey",o);const i=t.Buffer.from(e),a=n.encrypt(o,i);s=t.Buffer.from(a).toString("base64")}catch(t){throw this.debug&&(console.error("error encrypt:",t),console.error("private: ",this.ecies.toHex()),console.error("data: ",e),console.error("otherkey: ",o)),t}return s}decrypt(e){let o=e;if(this.enabled)try{this.debug&&console.debug("ECIES::decrypt() using privateKey",this.ecies.toHex());const s=t.Buffer.from(e.toString(),"base64");o=n.decrypt(this.ecies.toHex(),s).toString()}catch(t){throw this.debug&&(console.error("error decrypt",t),console.error("private: ",this.ecies.toHex()),console.error("encryptedData: ",e)),t}return o}getKeyInfo(){return{private:this.ecies.toHex(),public:this.ecies.publicKey.toHex()}}toString(){console.debug("ECIES::toString()",this.getKeyInfo())}}var d={name:"@metamask/sdk-communication-layer",version:"0.12.0",description:"",homepage:"https://github.com/MetaMask/metamask-sdk#readme",bugs:{url:"https://github.com/MetaMask/metamask-sdk/issues"},repository:{type:"git",url:"https://github.com/MetaMask/metamask-sdk.git",directory:"packages/sdk-communication-layer"},main:"dist/node/cjs/metamask-sdk-communication-layer.js",unpkg:"dist/browser/umd/metamask-sdk-communication-layer.js",module:"dist/node/es/metamask-sdk-communication-layer.js",browser:"dist/browser/es/metamask-sdk-communication-layer.js","react-native":"dist/react-native/es/metamask-sdk-communication-layer.js",types:"dist/browser/es/src/index.d.ts",files:["/dist"],scripts:{build:"rimraf dist && rollup -c --bundleConfigAsCjs","build:dev":"rimraf dist && NODE_ENV=dev rollup -c --bundleConfigAsCjs","build:post-tsc":"echo 'N/A'","build:pre-tsc":"echo 'N/A'",clean:"rimraf ./dist",lint:"yarn lint:eslint && yarn lint:misc --check","lint:changelog":"../../scripts/validate-changelog.sh @metamask/sdk-communication-layer","lint:eslint":"eslint . --cache --ext js,ts","lint:fix":"yarn lint:eslint --fix && yarn lint:misc --write","lint:misc":"prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore","prepare-manifest:preview":"../../scripts/prepare-preview-manifest.sh","publish:preview":"yarn npm publish --tag preview",prepack:"../../scripts/prepack.sh",reset:"yarn clean && rimraf ./node_modules/",test:"jest","test:coverage":"jest --coverage","test:ci":"jest --coverage --passWithNoTests","test:dev":"jest",watch:"rollup -c -w"},dependencies:{"cross-fetch":"^3.1.5","date-fns":"^2.29.3",eciesjs:"^0.3.16",eventemitter2:"^6.4.5","socket.io-client":"^4.5.1",uuid:"^8.3.2"},devDependencies:{"@jest/globals":"^29.3.1","@lavamoat/allow-scripts":"^2.3.1","@metamask/auto-changelog":"3.1.0","@metamask/eslint-config":"^6.0.0","@metamask/eslint-config-nodejs":"^6.0.0","@metamask/eslint-config-typescript":"^6.0.0","@rollup/plugin-commonjs":"^25.0.0","@rollup/plugin-json":"^6.0.0","@rollup/plugin-node-resolve":"^15.0.2","@rollup/plugin-terser":"^0.4.1","@types/jest":"^29.2.4","@types/node":"^20.1.3","@types/uuid":"^9.0.0","@typescript-eslint/eslint-plugin":"^4.26.0","@typescript-eslint/parser":"^4.26.0",eslint:"^7.30.0","eslint-config-prettier":"^8.3.0","eslint-plugin-import":"^2.23.4","eslint-plugin-jest":"^24.4.0","eslint-plugin-jsdoc":"^36.1.0","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^3.4.0",jest:"^29.3.1",prettier:"^2.3.0",rimraf:"^3.0.2",rollup:"^3.21.7","rollup-plugin-jscc":"^2.0.0","rollup-plugin-natives":"^0.7.5","rollup-plugin-node-builtins":"^2.1.2","rollup-plugin-node-globals":"^1.4.0","rollup-plugin-typescript2":"^0.31.2","rollup-plugin-visualizer":"^5.9.2","ts-jest":"^29.0.3","ts-node":"^10.9.1",typescript:"^4.3.2"},publishConfig:{access:"public",registry:"https://registry.npmjs.org/"},lavamoat:{allowScripts:{"@lavamoat/preinstall-always-fail":!1,canvas:!0,"eciesjs>secp256k1":!1,"socket.io-client>engine.io-client>ws>bufferutil":!1,"socket.io-client>engine.io-client>ws>utf-8-validate":!1}}};const l="https://metamask-sdk-socket.metafi.codefi.network/",u=["polling","websocket"],g=6048e5,h={METAMASK_GETPROVIDERSTATE:"metamask_getProviderState",ETH_REQUESTACCOUNTS:"eth_requestAccounts"};function p(e){const{debug:t,context:n}=e;t&&console.debug(`RemoteCommunication::${n}::clean()`),e.channelConfig=void 0,e.ready=!1,e.originatorConnectStarted=!1}var E,y,m,v,S;exports.ConnectionStatus=void 0,(E=exports.ConnectionStatus||(exports.ConnectionStatus={})).DISCONNECTED="disconnected",E.WAITING="waiting",E.TIMEOUT="timeout",E.LINKED="linked",E.PAUSED="paused",E.TERMINATED="terminated",exports.EventType=void 0,(y=exports.EventType||(exports.EventType={})).KEY_INFO="key_info",y.SERVICE_STATUS="service_status",y.PROVIDER_UPDATE="provider_update",y.RPC_UPDATE="rpc_update",y.KEYS_EXCHANGED="keys_exchanged",y.JOIN_CHANNEL="join_channel",y.CHANNEL_CREATED="channel_created",y.CLIENTS_CONNECTED="clients_connected",y.CLIENTS_DISCONNECTED="clients_disconnected",y.CLIENTS_WAITING="clients_waiting",y.CLIENTS_READY="clients_ready",y.SOCKET_DISCONNECTED="socket_disconnected",y.SOCKET_RECONNECT="socket_reconnect",y.OTP="otp",y.SDK_RPC_CALL="sdk_rpc_call",y.AUTHORIZED="authorized",y.CONNECTION_STATUS="connection_status",y.MESSAGE="message",y.TERMINATE="terminate",function(e){e.KEY_EXCHANGE="key_exchange"}(m||(m={})),function(e){e.KEY_HANDSHAKE_START="key_handshake_start",e.KEY_HANDSHAKE_CHECK="key_handshake_check",e.KEY_HANDSHAKE_SYN="key_handshake_SYN",e.KEY_HANDSHAKE_SYNACK="key_handshake_SYNACK",e.KEY_HANDSHAKE_ACK="key_handshake_ACK",e.KEY_HANDSHAKE_NONE="none"}(v||(v={}));class x extends o.EventEmitter2{constructor({communicationLayer:e,otherPublicKey:t,context:n,ecies:o,logging:s}){super(),this.keysExchanged=!1,this.step=v.KEY_HANDSHAKE_NONE,this.debug=!1,this.context=n,this.myECIES=new r(Object.assign(Object.assign({},o),{debug:null==s?void 0:s.eciesLayer})),this.communicationLayer=e,this.myPublicKey=this.myECIES.getPublicKey(),this.debug=!0===(null==s?void 0:s.keyExchangeLayer),t&&this.setOtherPublicKey(t),this.communicationLayer.on(m.KEY_EXCHANGE,this.onKeyExchangeMessage.bind(this))}onKeyExchangeMessage(e){this.debug&&console.debug(`KeyExchange::${this.context}::onKeyExchangeMessage() keysExchanged=${this.keysExchanged}`,e);const{message:t}=e;this.keysExchanged&&this.debug&&console.log(`KeyExchange::${this.context}::onKeyExchangeMessage received handshake while already exchanged. step=${this.step} otherPubKey=${this.otherPublicKey}`),t.type===v.KEY_HANDSHAKE_SYN?(this.checkStep([v.KEY_HANDSHAKE_NONE,v.KEY_HANDSHAKE_ACK]),this.debug&&console.debug("KeyExchange::KEY_HANDSHAKE_SYN",t),t.pubkey&&this.setOtherPublicKey(t.pubkey),this.communicationLayer.sendMessage({type:v.KEY_HANDSHAKE_SYNACK,pubkey:this.myPublicKey}),this.step=v.KEY_HANDSHAKE_ACK,this.emit(exports.EventType.KEY_INFO,this.step)):t.type===v.KEY_HANDSHAKE_SYNACK?(this.checkStep([v.KEY_HANDSHAKE_SYNACK,v.KEY_HANDSHAKE_NONE]),this.debug&&console.debug("KeyExchange::KEY_HANDSHAKE_SYNACK"),t.pubkey&&this.setOtherPublicKey(t.pubkey),this.communicationLayer.sendMessage({type:v.KEY_HANDSHAKE_ACK}),this.keysExchanged=!0,this.step=v.KEY_HANDSHAKE_NONE,this.emit(exports.EventType.KEYS_EXCHANGED)):t.type===v.KEY_HANDSHAKE_ACK&&(this.debug&&console.debug("KeyExchange::KEY_HANDSHAKE_ACK set keysExchanged to true!"),this.checkStep([v.KEY_HANDSHAKE_ACK,v.KEY_HANDSHAKE_NONE]),this.keysExchanged=!0,this.step=v.KEY_HANDSHAKE_NONE,this.emit(exports.EventType.KEYS_EXCHANGED))}resetKeys(e){this.clean(),this.myECIES=new r(e)}clean(){this.debug&&console.debug(`KeyExchange::${this.context}::clean reset handshake state`),this.step=v.KEY_HANDSHAKE_NONE,this.emit(exports.EventType.KEY_INFO,this.step),this.keysExchanged=!1}start({isOriginator:e,force:t}){this.debug&&console.debug(`KeyExchange::${this.context}::start isOriginator=${e} step=${this.step} force=${t} keysExchanged=${this.keysExchanged}`),e?!this.keysExchanged&&this.step===v.KEY_HANDSHAKE_NONE||t?(this.debug&&console.debug(`KeyExchange::${this.context}::start -- start key exchange (force=${t}) -- step=${this.step}`,this.step),this.clean(),this.step=v.KEY_HANDSHAKE_SYNACK,this.emit(exports.EventType.KEY_INFO,this.step),this.communicationLayer.sendMessage({type:v.KEY_HANDSHAKE_SYN,pubkey:this.myPublicKey})):this.debug&&console.debug(`KeyExchange::${this.context}::start -- key exchange already ${this.keysExchanged?"done":"in progress"} -- aborted.`,this.step):this.keysExchanged&&!0!==t?this.debug&&console.debug("KeyExchange::start don't send KEY_HANDSHAKE_START -- exchange already done."):(this.communicationLayer.sendMessage({type:v.KEY_HANDSHAKE_START}),this.clean())}checkStep(e){if(e.length>0&&-1===e.indexOf(this.step.toString()))throw new Error(`Wrong Step "${this.step}" not within ${e}`)}setKeysExchanged(e){this.keysExchanged=e}areKeysExchanged(){return this.keysExchanged}getMyPublicKey(){return this.myPublicKey}getOtherPublicKey(){return this.otherPublicKey}setOtherPublicKey(e){this.debug&&console.debug("KeyExchange::setOtherPubKey()",e),this.otherPublicKey=e}encryptMessage(e){if(!this.otherPublicKey)throw new Error("encryptMessage: Keys not exchanged - missing otherPubKey");return this.myECIES.encrypt(e,this.otherPublicKey)}decryptMessage(e){if(!this.otherPublicKey)throw new Error("decryptMessage: Keys not exchanged - missing otherPubKey");return this.myECIES.decrypt(e)}getKeyInfo(){return{ecies:Object.assign(Object.assign({},this.myECIES.getKeyInfo()),{otherPubKey:this.otherPublicKey}),step:this.step,keysExchanged:this.areKeysExchanged()}}toString(){const e={keyInfo:this.getKeyInfo(),keysExchanged:this.keysExchanged,step:this.step};return JSON.stringify(e)}}exports.MessageType=void 0,(S=exports.MessageType||(exports.MessageType={})).TERMINATE="terminate",S.ANSWER="answer",S.OFFER="offer",S.CANDIDATE="candidate",S.JSONRPC="jsonrpc",S.WALLET_INFO="wallet_info",S.ORIGINATOR_INFO="originator_info",S.PAUSE="pause",S.OTP="otp",S.AUTHORIZED="authorized",S.PING="ping",S.READY="ready";const C=e=>new Promise((t=>{setTimeout(t,e)})),k=(e,t,n=200)=>a(void 0,void 0,void 0,(function*(){let o;const s=Date.now();let i=!1;for(;!i;){if(i=Date.now()-s>3e5,o=t[e],void 0!==o.elapsedTime)return o;yield C(n)}throw new Error(`RPC ${e} timed out`)})),b=e=>a(void 0,void 0,void 0,(function*(){var t,n,o,s,i;return e.state.debug&&console.debug(`SocketService::connectAgain instance.state.socket?.connected=${null===(t=e.state.socket)||void 0===t?void 0:t.connected} trying to reconnect after socketio disconnection`,e),yield C(200),(null===(n=e.state.socket)||void 0===n?void 0:n.connected)||(e.state.resumed=!0,null===(o=e.state.socket)||void 0===o||o.connect(),e.emit(exports.EventType.SOCKET_RECONNECT),null===(s=e.state.socket)||void 0===s||s.emit(exports.EventType.JOIN_CHANNEL,e.state.channelId,`${e.state.context}connect_again`)),yield C(100),null===(i=e.state.socket)||void 0===i?void 0:i.connected}));function f(e){return t=>{e.state.debug&&console.debug(`SocketService::on 'disconnect' manualDisconnect=${e.state.manualDisconnect}`,t),e.state.manualDisconnect||(e.emit(exports.EventType.SOCKET_DISCONNECTED),function(e){"undefined"!=typeof window&&"undefined"!=typeof document&&(e.state.debug&&console.debug(`SocketService::checkFocus hasFocus=${document.hasFocus()}`,e),document.hasFocus()?b(e).then((t=>{e.state.debug&&console.debug(`SocketService::checkFocus reconnectSocket success=${t}`,e)})).catch((e=>{console.error("SocketService::checkFocus Error reconnecting socket",e)})):window.addEventListener("focus",(()=>{b(e).catch((e=>{console.error("SocketService::checkFocus Error reconnecting socket",e)}))}),{once:!0}))}(e))}}const T=[{event:"clients_connected",handler:function(e,t){return n=>a(this,void 0,void 0,(function*(){var n,o,s,i,a,c,r,d;e.state.debug&&console.debug(`SocketService::${e.state.context}::setupChannelListener::on 'clients_connected-${t}'  resumed=${e.state.resumed}  clientsPaused=${e.state.clientsPaused} keysExchanged=${null===(n=e.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged()} isOriginator=${e.state.isOriginator}`),e.emit(exports.EventType.CLIENTS_CONNECTED,{isOriginator:e.state.isOriginator,keysExchanged:null===(o=e.state.keyExchange)||void 0===o?void 0:o.areKeysExchanged(),context:e.state.context}),e.state.resumed?(e.state.isOriginator||(e.state.debug&&console.debug(`SocketService::${e.state.context}::on 'clients_connected' / keysExchanged=${null===(s=e.state.keyExchange)||void 0===s?void 0:s.areKeysExchanged()} -- backward compatibility`),null===(i=e.state.keyExchange)||void 0===i||i.start({isOriginator:null!==(a=e.state.isOriginator)&&void 0!==a&&a})),e.state.resumed=!1):e.state.clientsPaused?console.debug("SocketService::on 'clients_connected' skip sending originatorInfo on pause"):e.state.isOriginator||(e.state.debug&&console.debug(`SocketService::${e.state.context}::on 'clients_connected' / keysExchanged=${null===(c=e.state.keyExchange)||void 0===c?void 0:c.areKeysExchanged()} -- backward compatibility`),null===(r=e.state.keyExchange)||void 0===r||r.start({isOriginator:null!==(d=e.state.isOriginator)&&void 0!==d&&d,force:!0})),e.state.clientsConnected=!0,e.state.clientsPaused=!1}))}},{event:"channel_created",handler:function(e,t){return n=>{e.state.debug&&console.debug(`SocketService::${e.state.context}::setupChannelListener::on 'channel_created-${t}'`,n),e.emit(exports.EventType.CHANNEL_CREATED,n)}}},{event:"clients_disconnected",handler:function(e,t){return()=>{var n;e.state.clientsConnected=!1,e.state.debug&&console.debug(`SocketService::${e.state.context}::setupChannelListener::on 'clients_disconnected-${t}'`),e.state.isOriginator&&!e.state.clientsPaused&&(null===(n=e.state.keyExchange)||void 0===n||n.clean()),e.emit(exports.EventType.CLIENTS_DISCONNECTED,t)}}},{event:"message",handler:function(e,t){return({id:n,message:o,error:s})=>{var i,a,c,r,d,l,u,g,h,p,E,y,S,x,C;if(e.state.debug&&console.debug(`SocketService::${e.state.context}::on 'message' ${t} keysExchanged=${null===(i=e.state.keyExchange)||void 0===i?void 0:i.areKeysExchanged()}`,o),s)throw e.state.debug&&console.debug(`\n      SocketService::${e.state.context}::on 'message' error=${s}`),new Error(s);try{!function(e,t){if(t!==e.channelId)throw e.debug&&console.error(`Wrong id ${t} - should be ${e.channelId}`),new Error("Wrong id")}(e.state,n)}catch(e){return void console.error("ignore message --- wrong id ",o)}if(e.state.isOriginator&&(null==o?void 0:o.type)===v.KEY_HANDSHAKE_START)return e.state.debug&&console.debug(`SocketService::${e.state.context}::on 'message' received HANDSHAKE_START isOriginator=${e.state.isOriginator}`,o),void(null===(a=e.state.keyExchange)||void 0===a||a.start({isOriginator:null!==(c=e.state.isOriginator)&&void 0!==c&&c,force:!0}));if((null==o?void 0:o.type)===exports.MessageType.PING)return e.state.debug&&console.debug(`SocketService::${e.state.context}::on 'message' ping `),void e.emit(exports.EventType.MESSAGE,{message:{type:"ping"}});if(e.state.debug&&console.debug(`SocketService::${e.state.context}::on 'message' originator=${e.state.isOriginator}, type=${null==o?void 0:o.type}, keysExchanged=${null===(r=e.state.keyExchange)||void 0===r?void 0:r.areKeysExchanged()}`),null===(d=null==o?void 0:o.type)||void 0===d?void 0:d.startsWith("key_handshake"))return e.state.debug&&console.debug(`SocketService::${e.state.context}::on 'message' emit KEY_EXCHANGE`,o),void e.emit(m.KEY_EXCHANGE,{message:o,context:e.state.context});if(null===(l=e.state.keyExchange)||void 0===l?void 0:l.areKeysExchanged()){if(-1!==o.toString().indexOf("type"))return console.warn("SocketService::on 'message' received non encrypted unkwown message"),void e.emit(exports.EventType.MESSAGE,o)}else{let t=!1;try{null===(u=e.state.keyExchange)||void 0===u||u.decryptMessage(o),t=!0}catch(e){}if(!t)return e.state.isOriginator?null===(h=e.state.keyExchange)||void 0===h||h.start({isOriginator:null!==(p=e.state.isOriginator)&&void 0!==p&&p}):e.sendMessage({type:v.KEY_HANDSHAKE_START}),void console.warn(`Message ignored because invalid key exchange status. step=${null===(E=e.state.keyExchange)||void 0===E?void 0:E.getKeyInfo().step}`,null===(y=e.state.keyExchange)||void 0===y?void 0:y.getKeyInfo(),o);console.warn("Invalid key exchange status detected --- updating it."),null===(g=e.state.keyExchange)||void 0===g||g.setKeysExchanged(!0)}const k=null===(S=e.state.keyExchange)||void 0===S?void 0:S.decryptMessage(o),b=JSON.parse(null!=k?k:"{}");if((null==b?void 0:b.type)===exports.MessageType.PAUSE?e.state.clientsPaused=!0:e.state.clientsPaused=!1,e.state.isOriginator&&b.data){const t=b.data,n=e.state.rpcMethodTracker[t.id];if(n){const o=Date.now()-n.timestamp;e.state.debug&&console.debug(`SocketService::${e.state.context}::on 'message' received answer for id=${t.id} method=${n.method} responseTime=${o}`,b);const s=Object.assign(Object.assign({},n),{result:t.result,error:t.error?{code:null===(x=t.error)||void 0===x?void 0:x.code,message:null===(C=t.error)||void 0===C?void 0:C.message}:void 0,elapsedTime:o});e.state.rpcMethodTracker[t.id]=s,e.emit(exports.EventType.RPC_UPDATE),e.state.debug&&console.debug("HACK (wallet <7.3) update rpcMethodTracker",s),e.emit(exports.EventType.AUTHORIZED)}}e.emit(exports.EventType.MESSAGE,{message:b})}}},{event:"clients_waiting_to_join",handler:function(e,t){return n=>{e.state.debug&&console.debug(`SocketService::${e.state.context}::setupChannelListener::on 'clients_waiting_to_join-${t}'`,n),e.emit(exports.EventType.CLIENTS_WAITING,n)}}}],I=[{event:exports.EventType.KEY_INFO,handler:function(e){return t=>{e.state.debug&&console.debug("SocketService::on 'KEY_INFO'",t),e.emit(exports.EventType.KEY_INFO,t)}}},{event:exports.EventType.KEYS_EXCHANGED,handler:function(e){return()=>{var t,n;e.state.debug&&console.debug(`SocketService::on 'keys_exchanged' keyschanged=${null===(t=e.state.keyExchange)||void 0===t?void 0:t.areKeysExchanged()}`),e.emit(exports.EventType.KEYS_EXCHANGED,{keysExchanged:null===(n=e.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged(),isOriginator:e.state.isOriginator});const o={keyInfo:e.getKeyInfo()};e.emit(exports.EventType.SERVICE_STATUS,o)}}}];function _(e,t){e.state.debug&&console.debug(`SocketService::${e.state.context}::setupChannelListener setting socket listeners for channel ${t}...`);const{socket:n}=e.state,{keyExchange:o}=e.state;e.state.setupChannelListeners&&console.warn(`SocketService::${e.state.context}::setupChannelListener socket listeners already set up for channel ${t}`),n&&e.state.isOriginator&&(e.state.debug&&(null==n||n.io.on("error",(t=>{console.debug(`SocketService::${e.state.context}::setupChannelListener socket event=error`,t)})),null==n||n.io.on("reconnect",(t=>{console.debug(`SocketService::${e.state.context}::setupChannelListener socket event=reconnect`,t)})),null==n||n.io.on("reconnect_error",(t=>{console.debug(`SocketService::${e.state.context}::setupChannelListener socket event=reconnect_error`,t)})),null==n||n.io.on("reconnect_failed",(()=>{console.debug(`SocketService::${e.state.context}::setupChannelListener socket event=reconnect_failed`)})),null==n||n.io.on("ping",(()=>{console.debug(`SocketService::${e.state.context}::setupChannelListener socket event=ping`)}))),null==n||n.on("disconnect",(t=>(console.log(`MetaMaskSDK socket disconnected '${t}' begin recovery...`),f(e)(t))))),T.forEach((({event:o,handler:s})=>{const i=`${o}-${t}`;null==n||n.on(i,s(e,t))})),I.forEach((({event:t,handler:n})=>{null==o||o.on(t,n(e))})),e.state.setupChannelListeners=!0}function K(e,t){var n,o;if(!e.state.channelId)throw new Error("Create a channel first");e.state.debug&&console.debug(`SocketService::${e.state.context}::sendMessage() areKeysExchanged=${null===(n=e.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged()}`,t);(null===(o=null==t?void 0:t.type)||void 0===o?void 0:o.startsWith("key_handshake"))?function(e,t){var n;e.state.debug&&console.debug(`SocketService::${e.state.context}::sendMessage()`,t),null===(n=e.state.socket)||void 0===n||n.emit(exports.EventType.MESSAGE,{id:e.state.channelId,context:e.state.context,message:t})}(e,t):(!function(e,t){var n;if(!(null===(n=e.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged()))throw e.state.debug&&console.debug(`SocketService::${e.state.context}::sendMessage() ERROR keys not exchanged`,t),new Error("Keys not exchanged BBB")}(e,t),function(e,t){var n;const o=null!==(n=null==t?void 0:t.method)&&void 0!==n?n:"",s=null==t?void 0:t.id;e.state.isOriginator&&s&&(e.state.rpcMethodTracker[s]={timestamp:Date.now(),method:o},e.emit(exports.EventType.RPC_UPDATE))}(e,t),function(e,t){var n,o;const s=null===(n=e.state.keyExchange)||void 0===n?void 0:n.encryptMessage(JSON.stringify(t)),i={id:e.state.channelId,context:e.state.context,message:s,plaintext:e.state.hasPlaintext?JSON.stringify(t):void 0};e.state.debug&&console.debug(`SocketService::${e.state.context}::sendMessage()`,i),t.type===exports.MessageType.TERMINATE&&(e.state.manualDisconnect=!0),null===(o=e.state.socket)||void 0===o||o.emit(exports.EventType.MESSAGE,i)}(e,t),function(e,t){var n;return a(this,void 0,void 0,(function*(){const o=null==t?void 0:t.id,s=null!==(n=null==t?void 0:t.method)&&void 0!==n?n:"";if(e.state.isOriginator&&o)try{const n=yield k(o,e.state.rpcMethodTracker,200);e.state.debug&&console.debug(`SocketService::waitForRpc id=${t.id} ${s} ( ${n.elapsedTime} ms)`,n.result)}catch(e){console.warn(`Error rpcId=${t.id} ${s}`,e)}}))}(e,t).catch((e=>{console.warn("Error handleRpcReplies",e)})))}class N extends o.EventEmitter2{constructor({otherPublicKey:e,reconnect:t,communicationLayerPreference:n,transports:o,communicationServerUrl:s,context:a,ecies:c,logging:r}){super(),this.state={clientsConnected:!1,clientsPaused:!1,manualDisconnect:!1,rpcMethodTracker:{},hasPlaintext:!1,communicationServerUrl:""},this.state.resumed=t,this.state.context=a,this.state.communicationLayerPreference=n,this.state.debug=!0===(null==r?void 0:r.serviceLayer),this.state.communicationServerUrl=s,this.state.hasPlaintext=this.state.communicationServerUrl!==l&&!0===(null==r?void 0:r.plaintext);const d={autoConnect:!1,transports:u};o&&(d.transports=o),this.state.debug&&console.debug(`SocketService::constructor() Socket IO url: ${this.state.communicationServerUrl}`),this.state.socket=i.io(s,d);const g={communicationLayer:this,otherPublicKey:e,sendPublicKey:!1,context:this.state.context,ecies:c,logging:r};this.state.keyExchange=new x(g)}resetKeys(){return(e=this).state.debug&&console.debug("SocketService::resetKeys()"),void(null===(t=e.state.keyExchange)||void 0===t||t.resetKeys());var e,t}createChannel(){return function(e){var t,n,o,i;e.state.debug&&console.debug(`SocketService::${e.state.context}::createChannel()`),(null===(t=e.state.socket)||void 0===t?void 0:t.connected)||null===(n=e.state.socket)||void 0===n||n.connect(),e.state.manualDisconnect=!1,e.state.isOriginator=!0;const a=s.v4();return e.state.channelId=a,_(e,a),null===(o=e.state.socket)||void 0===o||o.emit(exports.EventType.JOIN_CHANNEL,a,`${e.state.context}createChannel`),{channelId:a,pubKey:(null===(i=e.state.keyExchange)||void 0===i?void 0:i.getMyPublicKey())||""}}(this)}connectToChannel({channelId:e,isOriginator:t=!1,withKeyExchange:n=!1}){return function({options:e,instance:t}){var n,o,s,i;const{channelId:a,withKeyExchange:c,isOriginator:r}=e;if(t.state.debug&&console.debug(`SocketService::${t.state.context}::connectToChannel() channelId=${a} isOriginator=${r}`,null===(n=t.state.keyExchange)||void 0===n?void 0:n.toString()),null===(o=t.state.socket)||void 0===o?void 0:o.connected)throw new Error("socket already connected");t.state.manualDisconnect=!1,null===(s=t.state.socket)||void 0===s||s.connect(),t.state.withKeyExchange=c,t.state.isOriginator=r,t.state.channelId=a,_(t,a),null===(i=t.state.socket)||void 0===i||i.emit(exports.EventType.JOIN_CHANNEL,a,`${t.state.context}_connectToChannel`)}({options:{channelId:e,isOriginator:t,withKeyExchange:n},instance:this})}getKeyInfo(){return this.state.keyExchange.getKeyInfo()}keyCheck(){var e,t;null===(t=(e=this).state.socket)||void 0===t||t.emit(exports.EventType.MESSAGE,{id:e.state.channelId,context:e.state.context,message:{type:v.KEY_HANDSHAKE_CHECK,pubkey:e.getKeyInfo().ecies.otherPubKey}})}getKeyExchange(){return this.state.keyExchange}sendMessage(e){return K(this,e)}ping(){return(e=this).state.debug&&console.debug(`SocketService::${e.state.context}::ping() originator=${e.state.isOriginator} keysExchanged=${null===(t=e.state.keyExchange)||void 0===t?void 0:t.areKeysExchanged()}`),e.state.isOriginator&&((null===(n=e.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged())?(console.warn(`SocketService::${e.state.context}::ping() sending READY message`),e.sendMessage({type:exports.MessageType.READY})):(console.warn(`SocketService::${e.state.context}::ping() starting key exchange`),null===(o=e.state.keyExchange)||void 0===o||o.start({isOriginator:null!==(s=e.state.isOriginator)&&void 0!==s&&s}))),void(null===(i=e.state.socket)||void 0===i||i.emit(exports.EventType.MESSAGE,{id:e.state.channelId,context:e.state.context,message:{type:exports.MessageType.PING}}));var e,t,n,o,s,i}pause(){return(e=this).state.debug&&console.debug(`SocketService::${e.state.context}::pause()`),e.state.manualDisconnect=!0,(null===(t=e.state.keyExchange)||void 0===t?void 0:t.areKeysExchanged())&&e.sendMessage({type:exports.MessageType.PAUSE}),void(null===(n=e.state.socket)||void 0===n||n.disconnect());var e,t,n}isConnected(){var e;return null===(e=this.state.socket)||void 0===e?void 0:e.connected}resume(){return(e=this).state.debug&&console.debug(`SocketService::${e.state.context}::resume() connected=${null===(t=e.state.socket)||void 0===t?void 0:t.connected} manualDisconnect=${e.state.manualDisconnect} resumed=${e.state.resumed} keysExchanged=${null===(n=e.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged()}`),(null===(o=e.state.socket)||void 0===o?void 0:o.connected)?e.state.debug&&console.debug("SocketService::resume() already connected."):(null===(s=e.state.socket)||void 0===s||s.connect(),e.state.debug&&console.debug(`SocketService::resume() after connecting socket --\x3e connected=${null===(i=e.state.socket)||void 0===i?void 0:i.connected}`),null===(a=e.state.socket)||void 0===a||a.emit(exports.EventType.JOIN_CHANNEL,e.state.channelId,`${e.state.context}_resume`)),(null===(c=e.state.keyExchange)||void 0===c?void 0:c.areKeysExchanged())?e.state.isOriginator||e.sendMessage({type:exports.MessageType.READY}):e.state.isOriginator||null===(r=e.state.keyExchange)||void 0===r||r.start({isOriginator:null!==(d=e.state.isOriginator)&&void 0!==d&&d}),e.state.manualDisconnect=!1,void(e.state.resumed=!0);var e,t,n,o,s,i,a,c,r,d}getRPCMethodTracker(){return this.state.rpcMethodTracker}disconnect(e){return function(e,t){var n,o;e.state.debug&&console.debug(`SocketService::${e.state.context}::disconnect()`,t),(null==t?void 0:t.terminate)&&(e.state.channelId=t.channelId,null===(n=e.state.keyExchange)||void 0===n||n.clean()),e.state.rpcMethodTracker={},e.state.manualDisconnect=!0,null===(o=e.state.socket)||void 0===o||o.disconnect()}(this,e)}}var A,O,D;function $(e){return()=>a(this,void 0,void 0,(function*(){var t,n,o;const{state:s}=e;if(s.authorized)return;yield(()=>a(this,void 0,void 0,(function*(){for(;!s.walletInfo;)yield C(500)})))();const i="7.3".localeCompare((null===(t=s.walletInfo)||void 0===t?void 0:t.version)||"");if(s.debug&&console.debug(`RemoteCommunication HACK 'authorized' version=${null===(n=s.walletInfo)||void 0===n?void 0:n.version} compareValue=${i}`),1!==i)return;const c=s.platformType===exports.PlatformType.MobileWeb||s.platformType===exports.PlatformType.ReactNative||s.platformType===exports.PlatformType.MetaMaskMobileWebview;s.debug&&console.debug(`RemoteCommunication HACK 'authorized' platform=${s.platformType} secure=${c} channel=${s.channelId} walletVersion=${null===(o=s.walletInfo)||void 0===o?void 0:o.version}`),c&&(s.authorized=!0,e.emit(exports.EventType.AUTHORIZED))}))}function w(e){return t=>{const{state:n}=e;n.debug&&console.debug(`RemoteCommunication::${n.context}::on 'channel_created' channelId=${t}`),e.emit(exports.EventType.CHANNEL_CREATED,t)}}function M(e,t){return()=>{var n,o,s,i;const{state:a}=e;if(a.debug&&console.debug(`RemoteCommunication::on 'clients_connected' channel=${a.channelId} keysExchanged=${null===(o=null===(n=a.communicationLayer)||void 0===n?void 0:n.getKeyInfo())||void 0===o?void 0:o.keysExchanged}`),a.analytics){const e=a.isOriginator?exports.TrackingEvents.REQUEST:exports.TrackingEvents.REQUEST_MOBILE;c(Object.assign(Object.assign({id:null!==(s=a.channelId)&&void 0!==s?s:"",event:a.reconnection?exports.TrackingEvents.RECONNECT:e},a.originatorInfo),{commLayer:t,sdkVersion:a.sdkVersion,walletVersion:null===(i=a.walletInfo)||void 0===i?void 0:i.version,commLayerVersion:d.version}),a.communicationServerUrl).catch((e=>{console.error("Cannot send analytics",e)}))}a.clientsConnected=!0,a.originatorInfoSent=!1,e.emit(exports.EventType.CLIENTS_CONNECTED)}}function R(e,t){return n=>{var o;const{state:s}=e;s.debug&&console.debug(`RemoteCommunication::${s.context}]::on 'clients_disconnected' channelId=${n}`),s.clientsConnected=!1,e.emit(exports.EventType.CLIENTS_DISCONNECTED,s.channelId),e.setConnectionStatus(exports.ConnectionStatus.DISCONNECTED),s.ready=!1,s.authorized=!1,s.analytics&&s.channelId&&c({id:s.channelId,event:exports.TrackingEvents.DISCONNECTED,sdkVersion:s.sdkVersion,commLayer:t,commLayerVersion:d.version,walletVersion:null===(o=s.walletInfo)||void 0===o?void 0:o.version},s.communicationServerUrl).catch((e=>{console.error("Cannot send analytics",e)}))}}function L(e){return t=>{var n;const{state:o}=e;if(o.debug&&console.debug(`RemoteCommunication::${o.context}::on 'clients_waiting' numberUsers=${t} ready=${o.ready} autoStarted=${o.originatorConnectStarted}`),e.setConnectionStatus(exports.ConnectionStatus.WAITING),e.emit(exports.EventType.CLIENTS_WAITING,t),o.originatorConnectStarted){o.debug&&console.debug(`RemoteCommunication::on 'clients_waiting' watch autoStarted=${o.originatorConnectStarted} timeout`,o.autoConnectOptions);const t=(null===(n=o.autoConnectOptions)||void 0===n?void 0:n.timeout)||3e3,s=setTimeout((()=>{o.debug&&console.debug(`RemoteCommunication::on setTimeout(${t}) terminate channelConfig`,o.autoConnectOptions),o.originatorConnectStarted=!1,o.ready||e.setConnectionStatus(exports.ConnectionStatus.TIMEOUT),clearTimeout(s)}),t)}}}function P(e,t){return n=>{var o,s,i,a,r;const{state:l}=e;l.debug&&console.debug(`RemoteCommunication::${l.context}::on commLayer.'keys_exchanged' channel=${l.channelId}`,n),(null===(s=null===(o=l.communicationLayer)||void 0===o?void 0:o.getKeyInfo())||void 0===s?void 0:s.keysExchanged)&&e.setConnectionStatus(exports.ConnectionStatus.LINKED),function(e,t){var n,o,s,i;const{state:a}=e;a.debug&&console.debug(`RemoteCommunication::setLastActiveDate() channel=${a.channelId}`,t);const c={channelId:null!==(n=a.channelId)&&void 0!==n?n:"",validUntil:null!==(s=null===(o=a.channelConfig)||void 0===o?void 0:o.validUntil)&&void 0!==s?s:0,lastActive:t.getTime()};null===(i=a.storageManager)||void 0===i||i.persistChannelConfig(c)}(e,new Date),l.analytics&&l.channelId&&c({id:l.channelId,event:n.isOriginator?exports.TrackingEvents.CONNECTED:exports.TrackingEvents.CONNECTED_MOBILE,sdkVersion:l.sdkVersion,commLayer:t,commLayerVersion:d.version,walletVersion:null===(i=l.walletInfo)||void 0===i?void 0:i.version},l.communicationServerUrl).catch((e=>{console.error("Cannot send analytics",e)})),l.isOriginator=n.isOriginator,n.isOriginator||(null===(a=l.communicationLayer)||void 0===a||a.sendMessage({type:exports.MessageType.READY}),l.ready=!0,l.paused=!1),n.isOriginator&&!l.originatorInfoSent&&(null===(r=l.communicationLayer)||void 0===r||r.sendMessage({type:exports.MessageType.ORIGINATOR_INFO,originatorInfo:l.originatorInfo,originator:l.originatorInfo}),l.originatorInfoSent=!0)}}function H(e,t){const{state:n}=t;if(n.debug&&console.debug(`RemoteCommunication::${n.context}::on 'message' typeof=${typeof e}`,e),t.state.ready=!0,n.isOriginator||e.type!==exports.MessageType.ORIGINATOR_INFO)if(n.isOriginator&&e.type===exports.MessageType.WALLET_INFO)!function(e,t){const{state:n}=e;n.walletInfo=t.walletInfo,n.paused=!1}(t,e);else{if(e.type===exports.MessageType.TERMINATE)!function(e){const{state:t}=e;t.isOriginator&&(F({options:{terminate:!0,sendMessage:!1},instance:e}),console.debug(),e.emit(exports.EventType.TERMINATE))}(t);else if(e.type===exports.MessageType.PAUSE)!function(e){const{state:t}=e;t.paused=!0,e.setConnectionStatus(exports.ConnectionStatus.PAUSED)}(t);else if(e.type===exports.MessageType.READY&&n.isOriginator)!function(e){const{state:t}=e;e.setConnectionStatus(exports.ConnectionStatus.LINKED);const n=t.paused;t.paused=!1,e.emit(exports.EventType.CLIENTS_READY,{isOriginator:t.isOriginator,walletInfo:t.walletInfo}),n&&(t.authorized=!0,e.emit(exports.EventType.AUTHORIZED))}(t);else{if(e.type===exports.MessageType.OTP&&n.isOriginator)return void function(e,t){var n;const{state:o}=e;e.emit(exports.EventType.OTP,t.otpAnswer),1==="6.6".localeCompare((null===(n=o.walletInfo)||void 0===n?void 0:n.version)||"")&&(console.warn("RemoteCommunication::on 'otp' -- backward compatibility <6.6 -- triger eth_requestAccounts"),e.emit(exports.EventType.SDK_RPC_CALL,{method:h.ETH_REQUESTACCOUNTS,params:[]}))}(t,e);e.type===exports.MessageType.AUTHORIZED&&n.isOriginator&&function(e){const{state:t}=e;t.authorized=!0,e.emit(exports.EventType.AUTHORIZED)}(t)}t.emit(exports.EventType.MESSAGE,e)}else!function(e,t){var n;const{state:o}=e;null===(n=o.communicationLayer)||void 0===n||n.sendMessage({type:exports.MessageType.WALLET_INFO,walletInfo:o.walletInfo}),o.originatorInfo=t.originatorInfo||t.originator,e.emit(exports.EventType.CLIENTS_READY,{isOriginator:o.isOriginator,originatorInfo:o.originatorInfo}),o.paused=!1}(t,e)}function Y(e,t){var n,o;return a(this,void 0,void 0,(function*(){const{state:s}=e;s.debug&&console.log(`RemoteCommunication::${s.context}::sendMessage paused=${s.paused} ready=${s.ready} authorized=${s.authorized} socket=${null===(n=s.communicationLayer)||void 0===n?void 0:n.isConnected()} clientsConnected=${s.clientsConnected} status=${s._connectionStatus}`,t),!s.paused&&s.ready&&(null===(o=s.communicationLayer)||void 0===o?void 0:o.isConnected())&&s.clientsConnected||(s.debug&&console.log(`RemoteCommunication::${s.context}::sendMessage  SKIP message waiting for MM mobile readiness.`),yield new Promise((t=>{e.once(exports.EventType.CLIENTS_READY,t)})),s.debug&&console.log(`RemoteCommunication::${s.context}::sendMessage  AFTER SKIP / READY -- sending pending message`));try{yield function(e,t){return a(this,void 0,void 0,(function*(){return new Promise((n=>{var o,s,i,a;const{state:c}=e;if(c.debug&&console.log(`RemoteCommunication::${c.context}::sendMessage::handleAuthorization ready=${c.ready} authorized=${c.authorized} method=${t.method}`),1==="7.3".localeCompare((null===(o=c.walletInfo)||void 0===o?void 0:o.version)||""))return c.debug&&console.debug(`compatibility hack wallet version > ${null===(s=c.walletInfo)||void 0===s?void 0:s.version}`),null===(i=c.communicationLayer)||void 0===i||i.sendMessage(t),void n();!c.isOriginator||c.authorized?(null===(a=c.communicationLayer)||void 0===a||a.sendMessage(t),n()):e.once(exports.EventType.AUTHORIZED,(()=>{var e;c.debug&&console.log(`RemoteCommunication::${c.context}::sendMessage  AFTER SKIP / AUTHORIZED -- sending pending message`),null===(e=c.communicationLayer)||void 0===e||e.sendMessage(t),n()}))}))}))}(e,t)}catch(e){throw console.error(`RemoteCommunication::${s.context}::sendMessage  ERROR`,e),e}}))}function U(e){return t=>{let n=t;t.message&&(n=n.message),H(n,e)}}function j(e){return()=>{const{state:t}=e;t.debug&&console.debug("RemoteCommunication::on 'socket_reconnect' -- reset key exchange status / set ready to false"),t.ready=!1,p(t)}}function G(e){return()=>{const{state:t}=e;t.debug&&console.debug("RemoteCommunication::on 'socket_Disconnected' set ready to false"),t.ready=!1}}function F({options:e,instance:t}){var n,o,i,a,c,r;const{state:d}=t;d.debug&&console.debug(`RemoteCommunication::disconnect() channel=${d.channelId}`,e),d.ready=!1,d.paused=!1,(null==e?void 0:e.terminate)?(null===(n=d.storageManager)||void 0===n||n.terminate(null!==(o=d.channelId)&&void 0!==o?o:""),(null===(i=d.communicationLayer)||void 0===i?void 0:i.getKeyInfo().keysExchanged)&&(null==e?void 0:e.sendMessage)&&(null===(a=d.communicationLayer)||void 0===a||a.sendMessage({type:exports.MessageType.TERMINATE})),d.channelId=s.v4(),e.channelId=d.channelId,d.channelConfig=void 0,d.originatorConnectStarted=!1,null===(c=d.communicationLayer)||void 0===c||c.disconnect(e),t.setConnectionStatus(exports.ConnectionStatus.TERMINATED)):(null===(r=d.communicationLayer)||void 0===r||r.disconnect(e),t.setConnectionStatus(exports.ConnectionStatus.DISCONNECTED))}exports.CommunicationLayerPreference=void 0,(exports.CommunicationLayerPreference||(exports.CommunicationLayerPreference={})).SOCKET="socket",exports.PlatformType=void 0,(A=exports.PlatformType||(exports.PlatformType={})).NonBrowser="nodejs",A.MetaMaskMobileWebview="in-app-browser",A.DesktopWeb="web-desktop",A.MobileWeb="web-mobile",A.ReactNative="react-native",exports.TrackingEvents=void 0,(O=exports.TrackingEvents||(exports.TrackingEvents={})).REQUEST="sdk_connect_request_started",O.REQUEST_MOBILE="sdk_connect_request_started_mobile",O.RECONNECT="sdk_reconnect_request_started",O.CONNECTED="sdk_connection_established",O.CONNECTED_MOBILE="sdk_connection_established_mobile",O.AUTHORIZED="sdk_connection_authorized",O.REJECTED="sdk_connection_rejected",O.TERMINATED="sdk_connection_terminated",O.DISCONNECTED="sdk_disconnected",O.SDK_USE_EXTENSION="sdk_use_extension",O.SDK_EXTENSION_UTILIZED="sdk_extension_utilized",O.SDK_USE_INAPP_BROWSER="sdk_use_inapp_browser";class z extends o.EventEmitter2{constructor({platformType:e,communicationLayerPreference:t,otherPublicKey:n,reconnect:o,walletInfo:s,dappMetadata:i,transports:a,context:c,ecies:r,analytics:d=!1,storage:u,sdkVersion:h,communicationServerUrl:p=l,logging:E,autoConnect:y={timeout:3e3}}){super(),this.state={ready:!1,authorized:!1,isOriginator:!1,paused:!1,platformType:"metamask-mobile",analytics:!1,reconnection:!1,originatorInfoSent:!1,communicationServerUrl:l,context:"",clientsConnected:!1,sessionDuration:g,originatorConnectStarted:!1,debug:!1,_connectionStatus:exports.ConnectionStatus.DISCONNECTED},this.state.otherPublicKey=n,this.state.dappMetadata=i,this.state.walletInfo=s,this.state.transports=a,this.state.platformType=e,this.state.analytics=d,this.state.isOriginator=!n,this.state.communicationServerUrl=p,this.state.context=c,this.state.sdkVersion=h,this.setMaxListeners(50),this.setConnectionStatus(exports.ConnectionStatus.DISCONNECTED),(null==u?void 0:u.duration)&&(this.state.sessionDuration=g),this.state.storageOptions=u,this.state.autoConnectOptions=y,this.state.debug=!0===(null==E?void 0:E.remoteLayer),this.state.logging=E,(null==u?void 0:u.storageManager)&&(this.state.storageManager=u.storageManager),this.initCommunicationLayer({communicationLayerPreference:t,otherPublicKey:n,reconnect:o,ecies:r,communicationServerUrl:p}),this.emitServiceStatusEvent()}initCommunicationLayer({communicationLayerPreference:e,otherPublicKey:t,reconnect:n,ecies:o,communicationServerUrl:s=l}){return function({communicationLayerPreference:e,otherPublicKey:t,reconnect:n,ecies:o,communicationServerUrl:s=l,instance:i}){var a,c,r;const{state:u}=i;if(e!==exports.CommunicationLayerPreference.SOCKET)throw new Error("Invalid communication protocol");u.communicationLayer=new N({communicationLayerPreference:e,otherPublicKey:t,reconnect:n,transports:u.transports,communicationServerUrl:s,context:u.context,ecies:o,logging:u.logging});let g="undefined"!=typeof document&&document.URL||"",h="undefined"!=typeof document&&document.title||"";(null===(a=u.dappMetadata)||void 0===a?void 0:a.url)&&(g=u.dappMetadata.url),(null===(c=u.dappMetadata)||void 0===c?void 0:c.name)&&(h=u.dappMetadata.name);const p={url:g,title:h,source:null===(r=u.dappMetadata)||void 0===r?void 0:r.source,platform:u.platformType,apiVersion:d.version};u.originatorInfo=p;const E={[exports.EventType.AUTHORIZED]:$(i),[exports.EventType.MESSAGE]:U(i),[exports.EventType.CLIENTS_CONNECTED]:M(i,e),[exports.EventType.KEYS_EXCHANGED]:P(i,e),[exports.EventType.SOCKET_DISCONNECTED]:G(i),[exports.EventType.SOCKET_RECONNECT]:j(i),[exports.EventType.CLIENTS_DISCONNECTED]:R(i,e),[exports.EventType.CHANNEL_CREATED]:w(i),[exports.EventType.CLIENTS_WAITING]:L(i),[exports.EventType.RPC_UPDATE]:()=>{i.emit(exports.EventType.RPC_UPDATE)}};for(const[e,t]of Object.entries(E))try{u.communicationLayer.on(e,t)}catch(t){console.error(`Error registering handler for ${e}:`,t)}}({communicationLayerPreference:e,otherPublicKey:t,reconnect:n,ecies:o,communicationServerUrl:s,instance:this})}originatorSessionConnect(){return a(this,void 0,void 0,(function*(){return yield function(e){var t,n,o;return a(this,void 0,void 0,(function*(){const{state:s}=e;if(!s.storageManager)return void(s.debug&&console.debug("RemoteCommunication::connect() no storage manager defined - skip"));const i=yield s.storageManager.getPersistedChannelConfig(null!==(t=s.channelId)&&void 0!==t?t:"");if(s.debug&&console.debug(`RemoteCommunication::connect() autoStarted=${s.originatorConnectStarted} channelConfig`,i),null===(n=s.communicationLayer)||void 0===n?void 0:n.isConnected())return s.debug&&console.debug("RemoteCommunication::connect() socket already connected - skip"),i;if(i){if(i.validUntil>Date.now())return s.channelConfig=i,s.originatorConnectStarted=!0,s.channelId=null==i?void 0:i.channelId,s.reconnection=!0,null===(o=s.communicationLayer)||void 0===o||o.connectToChannel({channelId:i.channelId,isOriginator:!0}),i;s.debug&&console.log("RemoteCommunication::autoConnect Session has expired")}s.originatorConnectStarted=!1}))}(this)}))}generateChannelIdConnect(){return a(this,void 0,void 0,(function*(){return function(e){var t,n,o,s,i;if(!e.communicationLayer)throw new Error("communication layer not initialized");if(e.ready)throw new Error("Channel already connected");if(e.channelId&&(null===(t=e.communicationLayer)||void 0===t?void 0:t.isConnected()))return console.warn("Channel already exists -- interrupt generateChannelId",e.channelConfig),e.channelConfig={channelId:e.channelId,validUntil:Date.now()+e.sessionDuration},null===(n=e.storageManager)||void 0===n||n.persistChannelConfig(e.channelConfig),{channelId:e.channelId,pubKey:null===(s=null===(o=e.communicationLayer)||void 0===o?void 0:o.getKeyInfo())||void 0===s?void 0:s.ecies.public};e.debug&&console.debug("RemoteCommunication::generateChannelId()"),p(e);const a=e.communicationLayer.createChannel();e.debug&&console.debug("RemoteCommunication::generateChannelId() channel created",a);const c={channelId:a.channelId,validUntil:Date.now()+e.sessionDuration};return e.channelId=a.channelId,e.channelConfig=c,null===(i=e.storageManager)||void 0===i||i.persistChannelConfig(c),{channelId:e.channelId,pubKey:a.pubKey}}(this.state)}))}clean(){return p(this.state)}connectToChannel(e,t){return function({channelId:e,withKeyExchange:t,state:n}){var o,i,a;if(!s.validate(e))throw console.debug(`RemoteCommunication::${n.context}::connectToChannel() invalid channel channelId=${e}`),new Error(`Invalid channel ${e}`);if(n.debug&&console.debug(`RemoteCommunication::${n.context}::connectToChannel() channelId=${e}`),null===(o=n.communicationLayer)||void 0===o?void 0:o.isConnected())return void console.debug(`RemoteCommunication::${n.context}::connectToChannel() already connected - interrup connection.`);n.channelId=e,null===(i=n.communicationLayer)||void 0===i||i.connectToChannel({channelId:e,withKeyExchange:t});const c={channelId:e,validUntil:Date.now()+n.sessionDuration};n.channelConfig=c,null===(a=n.storageManager)||void 0===a||a.persistChannelConfig(c)}({channelId:e,withKeyExchange:t,state:this.state})}sendMessage(e){return Y(this,e)}testStorage(){return a(this,void 0,void 0,(function*(){return function(e){var t,n;return a(this,void 0,void 0,(function*(){const o=yield null===(t=e.storageManager)||void 0===t?void 0:t.getPersistedChannelConfig(null!==(n=e.channelId)&&void 0!==n?n:"");console.debug("RemoteCommunication.testStorage() res",o)}))}(this.state)}))}getChannelConfig(){return this.state.channelConfig}isReady(){return this.state.ready}isConnected(){var e;return null===(e=this.state.communicationLayer)||void 0===e?void 0:e.isConnected()}isAuthorized(){return this.state.authorized}isPaused(){return this.state.paused}getCommunicationLayer(){return this.state.communicationLayer}ping(){var e;this.state.debug&&console.debug(`RemoteCommunication::ping() channel=${this.state.channelId}`),null===(e=this.state.communicationLayer)||void 0===e||e.ping()}keyCheck(){var e;this.state.debug&&console.debug(`RemoteCommunication::keyCheck() channel=${this.state.channelId}`),null===(e=this.state.communicationLayer)||void 0===e||e.keyCheck()}setConnectionStatus(e){this.state._connectionStatus!==e&&(this.state._connectionStatus=e,this.emit(exports.EventType.CONNECTION_STATUS,e),this.emitServiceStatusEvent())}emitServiceStatusEvent(){this.emit(exports.EventType.SERVICE_STATUS,this.getServiceStatus())}getConnectionStatus(){return this.state._connectionStatus}getServiceStatus(){return{originatorInfo:this.state.originatorInfo,keyInfo:this.getKeyInfo(),connectionStatus:this.state._connectionStatus,channelConfig:this.state.channelConfig,channelId:this.state.channelId}}getKeyInfo(){var e;return null===(e=this.state.communicationLayer)||void 0===e?void 0:e.getKeyInfo()}resetKeys(){var e;null===(e=this.state.communicationLayer)||void 0===e||e.resetKeys()}setOtherPublicKey(e){var t;const n=null===(t=this.state.communicationLayer)||void 0===t?void 0:t.getKeyExchange();if(!n)throw new Error("KeyExchange is not initialized.");n.getOtherPublicKey()!==e&&n.setOtherPublicKey(e)}pause(){var e;this.state.debug&&console.debug(`RemoteCommunication::pause() channel=${this.state.channelId}`),null===(e=this.state.communicationLayer)||void 0===e||e.pause(),this.setConnectionStatus(exports.ConnectionStatus.PAUSED)}getVersion(){return d.version}resume(){return function(e){var t;const{state:n}=e;n.debug&&console.debug(`RemoteCommunication::resume() channel=${n.channelId}`),null===(t=n.communicationLayer)||void 0===t||t.resume(),e.setConnectionStatus(exports.ConnectionStatus.LINKED)}(this)}getChannelId(){return this.state.channelId}getRPCMethodTracker(){var e;return null===(e=this.state.communicationLayer)||void 0===e?void 0:e.getRPCMethodTracker()}disconnect(e){return F({options:e,instance:this})}}exports.AutoConnectType=void 0,(D=exports.AutoConnectType||(exports.AutoConnectType={})).RENEW="renew",D.LINK="link",exports.DEFAULT_SERVER_URL=l,exports.ECIES=r,exports.RemoteCommunication=z,exports.SendAnalytics=c,exports.SocketService=N;
//# sourceMappingURL=metamask-sdk-communication-layer.js.map
